;
; LIGHTHOUSE OF DOOM!!!
;
; Steve Kemp
; -
; https://steve.kemp.fi/
; https://github.com/skx/lighthouse-of-doom
;
;
; This is a port of the lighthouse-of-doom game from C to Z80 assembly, such
; that it will run under CP/M 2.x and the 48k ZX Spectrum.
;
; Although the game has been ported that process has resulted in some changes
; to the text, and the command-handlers.  If you've played the C game, and
; completed it, there will be no significant new surprises.
;
; Rather than having a global player-inventory store, and a place
; in each location for object storage we've instead make the location
; a property of each item.
;
;
; Known deficiencies / bugs
; -------------------------
;
;   HELP command doesn't show description next to command.
;
;
; Naming / Code Layout
; --------------------
;
; I've tried to be consistent with naming-schemes, but of course some
; code was added in an ad-hoc fashion:
;
;   * All functions with a _command suffix are command-handlers
;     These are invoked as a result of the user typing the appropriate
;     string.  e.g. User types "EXAMINE" we run "examine_function"
;
;   * All object-specific functions have a _fn suffix.
;     e.g. Custom code runs when you "GET RUG" is get_rug_fn
;
; If you're using Emacs, or similar editor, you should be able to fold
; or collapse sections of the code via the markers "; {" and "; }"
;



; Game over if you don't win in this many turns
MAX_TURN_LIMIT: EQU 100

; Maximum number of turns you can survive being near a grue
MAX_GRUE_EXPOSURE: EQU 3

; Later we have an object-table, containing entries for all of the
; objects which are present in the game.  Some of these objects are
; real in the sense that they can be used/taken.  Others exist only
; so they may be examined.
;
; Each object has a description, a state, and a location, along with
; a collection of dedicated handler-functions.
;
; Here we define some state attributes for a couple of special objects
; which eases maintainance.
;
; 1. Torch may be lit or unlit.
TORCH_STATE_UNLIT:      EQU 0
TORCH_STATE_LIT:        EQU 1

; 2. The trapdoor may be invisible, open, or closed.
;    [The objects have an invisible state, but we can't use that here.]
TRAPDOOR_STATE_INVISIBLE:  EQU 0
TRAPDOOR_STATE_CLOSED:     EQU 1
TRAPDOOR_STATE_OPEN:       EQU 2

; 3. The mirror may be normal, or broken
MIRROR_OK:     EQU 0
MIRROR_BROKEN: EQU 1

;
; Each item also contains a byte which holds the "location" (i.e. index
; into the location-map).  Two locations are special:
;
; - A location of 0xff means the player is carrying the item.
;
; - A location of 0xfe means the item is available, but invisible.
;
; These are defined here for clarity.
;
ITEM_CARRIED:   EQU 0xff
ITEM_INVISIBLE: EQU 0xfe



;********************************************************************
; Macros
;********************************************************************
; {{

;
; Simple macro to inject "L" into our input buffer, and call the LOOK handler.
;
MACRO FAKE_LOOK
        ld hl, INPUT_BUFFER+2
        ld (hl), 'L'
        call look_function
      ENDM


;
; Simple macro to push all (important) registers.
;
MACRO PUSH_ALL
        push af
        push bc
        push de
        push hl
      ENDM


;
; Simple macro to pop all (important) registers.
;
MACRO POP_ALL
        pop hl
        pop de
        pop bc
        pop af
      ENDM
; }}


;********************************************************************
; Entry-point and initial setup
;********************************************************************
; {{

        ;
        ; Entry-point of CP/M binaries is 0x100, as the zero-page, or PSP,
        ; is located before that:
        ;
        ;     https://en.wikipedia.org/wiki/Zero_page_(CP/M)
        ;
        ; Entry-point for the ZX Spectrum port is 32768, chosen randomly.
        ;
        ORG ENTRYPOINT

        ;
        ; Our game can be compiled with optional "encryption", which uses
        ; a simple scheme to hide the strings in our binary.
        ;
        ; If this support is used we'll have to restore our contents, or
        ; the game won't be playable.
        ;
        ; To compile the binary with encryption you need to define the
        ; `ENCRYPT_STRINGS` symbol, and then post-process the binary
        ; with `encrypt.c`.
        ;
IF ENCRYPT_STRINGS
        ld hl, ENC                      ; start of region to unmangle
        ld de, ( end_of_source - ENC )  ; length to unmangle.
        ld c, '%'                       ; starting scrambling key (XOR)
enc_loop:
        ld a,(hl)          ; get the byte
        xor c              ; modify it
        ld (hl),a          ; store it back
        inc hl             ; point to the next byte
        dec de             ; decrease count of remaining bytes to process.
        inc c              ; bump key
        ld a, d            ; done?
        or e
        jr nz,enc_loop     ; no, then repeat

        jp enc_end         ; Jump over our marker to the start of the game.

        ;
        ; Everything after here will be encrypted.
        ;
        ENC: DB "SKX"
enc_end:
ENDIF

        ; Call system-specific setup routine before we do anything else.
        call bios_init


        ; Here we're going to copy our game-state to the end of RAM
        ;
        ; We do this so that everything "resets" if the player dies/wins
        ; and then chooses to play again when prompted.
        ;
        ; We don't know for sure how big the data is, but we assume it'll
        ; fit from 0xD000..
        ld hl, per_game_state_start
        ld de, 0xD000
        ld bc, end_of_source - per_game_state_start
        ldir

;; }}


;********************************************************************
; Main game-loop
;********************************************************************
; {{

game_start:

        ; Reset the state of the the inventory, the game-world, etc.
        ;
        ; This is pointless at the start of the game, as nothing is
        ; modified, but we jump here if the user chooses to replay the
        ; game, so we have it here for that reason.
        ld hl, 0xD000
        ld de, per_game_state_start
        ld bc, end_of_source - per_game_state_start
        ldir

        ; Clear the screen
        call bios_clear_screen

        ; Present the game intro-text.
        ; Set the wrapping to be 60 characters to ensure there's no weirdness
        ld hl, WRAP_LOCATION
        ld a, (hl)
        push af
        ld (hl), 60
        ld de, usage_message
        call bios_output_string
        pop af
        ld (hl),a

        ; Pause for input here.
        call bios_await_keypress
        call bios_clear_screen

        ; Show the starting-location.
        FAKE_LOOK

        ; The start of our game loop.
        ;
        ; Here we basically read a line of input, process it, then
        ; attempt to call the appropriate handler.  This repeats until
        ; the game is over, one way or another.
        ;
        ; We upper-case all input to allow easier matching to our
        ; command/dispatch-table.
game_loop:

        ; Have we exceeded the turn-count?
        ld hl, TURN_COUNT
        ld a, (hl)
        cp MAX_TURN_LIMIT
        jp c,game_loop_continue

        ld hl, PLAYER_DEAD_FLAG
        inc (hl)

game_loop_continue:

        ; Did the player die of a magic-overdoes
        ld hl, PLAYER_MAGIC_OVERDOSE_FLAG
        ld a, (hl)
        cp 1
        jp z, play_again

        ; Is the player dead?
        ld hl, PLAYER_DEAD_FLAG
        ld a, (hl)
        cp 1
        jp nz,not_dead

        ; The player is dead.  Oops.
        ld de, PLAYER_DEAD_MESSAGE
        call bios_output_string
        call turns_function
        jp play_again

not_dead:
        ; Did the player win?
        ld hl, PLAYER_WON_FLAG
        ld a, (hl)
        cp 1
        jp nz, not_won

        ; The player won.  Yay!
        ld de, PLAYER_WON_MESSAGE
        call bios_output_string
        call turns_function
        jp play_again

not_won:

        ; Erase our input buffer.
        ld hl, INPUT_BUFFER+2
        ld b, 0xff
        call erase_buffer

        ; Read a line of input from the player.
        ld de, INPUT_BUFFER
        call bios_read_input

        ; Every ten turns we show a message about the ship.
        ld hl, SHIP_WARNING
        ld a, (hl)              ; get the value
        cp 10                   ; ten turns?
        jr nz, no_ship_warning  ; nope?  Do nothing

        ld (hl), 0              ; reset the count
        ld de, ship_closer_msg  ; show the message
        call bios_output_string
        call show_dots
        call bios_clear_screen
        jp ship_warning_over

no_ship_warning:
        inc (hl)                ; increase our count
ship_warning_over:
        ; If the input was zero-length (i.e. User pressed return) ignore it.
        ld hl, INPUT_BUFFER+1
        ld a,(hl)
        cp 0
        jr z, not_won

        ; Convert the input to upper-case.
        ld b,a
        inc hl
        call uppercase_buffer

        ; Strip out " THE " from any input
        ;
        ; This means input is fixed for simple case:
        ;
        ;    "USE THE TORCH"    -> "USE TORCH"
        ;    "EXAMINE THE BOOK" -> "EXAMINE BOOK"
        ;
        ; Not ideal, but more useable
        call filter_input_buffer

        ; Take the input from the user, and see if we have a registered
        ; command with that name.  If we do we can invoke it, but if not we've
        ; been given something we don't understand.
        ld hl, INPUT_BUFFER+2
        call find_command
        cp 255
        jp z, no_handler
        push hl

        ; Valid command - increase turn count
        ld hl, TURN_COUNT
        inc (hl)

        ; Call the handler
        pop hl
        call JP_HL

        ; Did we get eaten?
        call maybe_grue_death

        ; And restart the command-loop
        jp game_loop


no_handler:
        ; Show the user that their command wasn't understood.
        ld de, invalid_msg
        call bios_output_string

        ; Did we get eaten?
        call maybe_grue_death

        ; Return to the start of our game-loop.
        jp game_loop

; }}



;********************************************************************
; Include our custom printing routine
;********************************************************************
include "prn.z80"



;********************************************************************
; Utility functions
;********************************************************************
; {{

; compare strings stored in HL + DE for equality.  Length is stored in B
; Returns NZ if they're not equal.
CompareStringsWithLength:
    ld a,(de)
    cp (hl)
    ret nz     ;nz means they are not equal
    inc hl
    inc de
    djnz CompareStringsWithLength
    xor a
    ret


;
; Helper function, to allow indirection.
;
JP_HL:
    jp (hl)


;
; Show some significant dots
;
show_dots:
        ; width of the screen
        ld b, MAX_INPUT_LENGTH - 1
dot_loop:
        PUSH_ALL
         call bios_delay
         ld e, '.'
         call bios_output_character
        POP_ALL
        djnz dot_loop
        ret





; Multiply two 8-bit values together.
; INPUT: THE VALUES IN REGISTER B EN C
; OUTPUT: HL = B * C
; CHANGES: AF,DE,HL,B
;
multiply:
	LD HL,0
	LD A,B
	OR A
	RET Z
	LD D,0
	LD E,C
LOOP:	ADD HL,DE
	DJNZ LOOP
	RET

;
; Output number helpers - used for reporting the number of turns
; you have taken, as well as showing the wrap-value via "WRAP".
;
DispHL:
	ld	bc,-10000
	call	Num1
	ld	bc,-1000
	call	Num1
	ld	bc,-100
	call	Num1
	ld	c,-10
	call	Num1
	ld	c,-1
Num1:	ld	a,'0'-1
Num2:	inc	a
	add	hl,bc
	jr	c,Num2
	sbc	hl,bc

        PUSH_ALL

        ld e, a
        call bios_output_character

        POP_ALL
	ret

show_a_register:
        PUSH_ALL
        ld h,0
	ld l,a
	call DispHL
        POP_ALL
        ret

;Input:
;     DE points to the string
;Outputs:
;     HL is the result
;     A is the 8-bit value of the number
;     DE points to the byte after the number
;Destroys:
;     BC
;       if the string is non-empty, BC is HL/10
string_to_uint16:
atoui_16:
        ld hl,0
string_to_uint16_loop:
        ld a,(de)
        sub 30h
        cp 10
        ret nc
        inc de
        ld b,h
        ld c,l
        add hl,hl
        add hl,hl
        add hl,bc
        add hl,hl
        add a,l
        ld l,a
        jr nc,string_to_uint16_loop
        inc h
        jp string_to_uint16_loop


;
; Helper function, fill a region of memory with zero characters
;
;  HL will point to the buffer.
;   B will have the length
erase_buffer:
        xor a
erase_buffer_loop:
        ld (hl),a
        inc hl
        djnz erase_buffer_loop
        ret


;
; Helper function.  Upper-case the given string.
;
;  HL will point to the buffer.
;   B will have the length
;
uppercase_buffer:
        ld a, (hl)
        cp 'a'-1
        jr c, uppercase_ok
        cp 'z'+1
        jr nc, uppercase_ok
        sub 32
        ld (hl),a
uppercase_ok:
        inc hl
        djnz uppercase_buffer
        ret



;
; Helper function, filter our input buffer, by removing some words
;
filter_input_buffer:
        call filter_input_buffer_on
        call filter_input_buffer_the
        ret


;
; Helper function.  Remove " ON " from any input
;
filter_input_buffer_on:
        ld hl, INPUT_BUFFER+1
        ld a, (hl)
        ld b, a                ; b contains the number of chacters
        inc hl                 ; hl points to the text the user entered

compare_loop_on:
        push bc    ; preserve count
        push hl    ; preserve starting char

        ld b, 4  ; strlen(" ON " )
        ld de, ON

        call CompareStringsWithLength
        jp z, we_found_on

        pop hl
        pop bc

        inc hl
        djnz compare_loop_on

        ; Didn't find " THE " at any character position in the input-buffer.
        ret

we_found_on:
        pop hl
        pop de

        ; we have " THE " at the location HL points to
        ld a, " "
        ld (hl), a   ; " " -> " "
        inc hl
        ld (hl), a   ; "O" -> " "
        inc hl
        ld (hl), a   ; "N" -> " "
        ret


;
; Helper function.  Remove " THE " from any input.
;
filter_input_buffer_the:

        ld hl, INPUT_BUFFER+1
        ld a, (hl)
        ld b, a                ; b contains the number of chacters
        inc hl                 ; hl points to the text the user entered

compare_loop_the:
        push bc    ; preserve count
        push hl    ; preserve starting char

        ld b, 5  ; strlen(" THE " )
        ld de, THE

        call CompareStringsWithLength
        jp z, we_found_the

        pop hl
        pop bc

        inc hl
        djnz compare_loop_the

        ; Didn't find " THE " at any character position in the input-buffer.
        ret

we_found_the:
        pop hl
        pop de

        ; we have " THE " at the location HL points to
        ld a, " "
        ld (hl), a   ; " " -> " "
        inc hl
        ld (hl), a   ; "T" -> " "
        inc hl
        ld (hl), a   ; "H" -> " "
        inc hl
        ld (hl), a   ; "E" -> " "
        inc hl
        ld (hl), a   ; " " -> " "
        inc hl
        ret
; }}


;********************************************************************
; Utility Functions For Game
;********************************************************************
; {{


;
; Ask the user if they wish to play again
;
play_again:
        ld de, play_again_msg
        call bios_output_string

        call bios_await_keypress
        cp 'y'
        jr z, play_again_yes
        cp 'Y'
        jr z, play_again_yes
        cp 'n'
        jr z, play_again_no
        cp 'N'
        jr z, play_again_no
        call bios_clear_screen
        jr play_again


; User chose "Y" to "play again?"
play_again_yes:
        jp game_start

; User chose "N" to "play again?"
play_again_no:
        ld de, play_again_no_msg
        call bios_output_string
IF SPECTRUM
        pop de
        ret
ELSE
        ld c, 0x0
        call 0x0005
        ret
ENDIF


; This will be a major part of our code so it is perhaps a little more
; verbose than it wants to be.
;
; Find the entry in the command-table.  If we find it return the address
; of the routine to call in `HL`.
;
; On entry `HL` should contain the pointer to the input buffer to look
; for.
;
; On exit A contains 0 on success, with HL pointing to the handler to invoke,
; or A contains 255 on failure.
find_command:
        ld de,command_table

        ;
        ; Entries are arranged like so:
        ;   $LENGTH "ASCII" $HIDDEN ADDR1 ADDR2
        ;
        ; Where $LENGTH is the length of the ASCII command-name.
        ;
        ; So:
        ;
        ;   4, "QUIT", 0, quit_fn_ptr
        ;   3, "CLS",  1, cls_fn_ptr
        ;   0,
        ;
        ; "HIDDEN" is used solely to decide whether the command should be
        ; included in the output of "HELP".
        ;
find_command_again:
        push de
        ld a, (de)  ; length of string
        cp 0x00     ; zero?  We've hit the end of the table and not found
        jr nz, cont ; a match - return failure
        pop de
        ld a,255
        ret
cont:
        ld b, a    ; B will contain the length
        inc de     ; DE point to the string itself

        push hl
        call CompareStringsWithLength
        jp z,find_command_found
        pop hl

        ; ok we didn't find a match with this command-table entry.

        ; restore DE which points to this entry's start
        pop de

        ld a, (de)           ; get the length of the command-name
        inc de               ; point to the command-name
        ld b,a               ; bump the pointer past the ASCII string, in a loop
find_command_skip:
        inc de
        djnz find_command_skip
        inc de                 ; bump past the hidden-flag
        inc de                 ; bump past the addr1-byte
        inc de                 ; bump past the addr2-byte
        jp  find_command_again ; loop back to try the next table entry.

find_command_found:
        ; drop hl
        pop hl

        ; restore the pointer to the start of this command-table entry.
        pop de

        ; Once again we need to bump past the length, and the ASCII string
        ; itself.  Now we know we've got a match we want to get the address
        ; of the handler to invoke.
        ld a, (de)              ; get the length
        inc de                  ; move to the start of the string
        ld b,a
find_command_skip2:             ; skip $LENGTH-bytes
        inc de
        djnz find_command_skip2
        inc de                  ; skip the hidden-flag
        ld a, (de)              ; set l
        ld l,a
        inc de
        ld a, (de)              ; set h
        ld h,a
        xor a                  ; indicate success
        ret                    ; return with the function-pointer in HL


;
; Helper function.  Are ANY items present in this room?
;
; This is just used to know whether to print the "You can see .." message
;
; Return "A == 0" if so.
; Return "A == FF" if not
;
items_are_present:

        ; Point to the item-table, and prepare to loop over the items
        ld IX, items
        ld DE, ITEM_ENTRY_LENGTH
        ld b, ITEM_COUNT

look_item_loop_test:

        ; Get the location of the object in C
        ld c, (IX+ITEM_TABLE_LOCATION_OFFSET)

        ; Set A to the current location.
        ld hl, CURRENT_LOCATION
        ld a,(hl)

        ; Is the item in the room?
        cp c
        jr nz, item_not_present_loop

        ; Get the description of the object in HL.
        ld l, (IX+ITEM_TABLE_DESCRIPTION_OFFSET)
        ld h, (IX+ITEM_TABLE_DESCRIPTION_OFFSET+1)

        ; OK we have an item present.  Is the description empty?
        ; if so that's a hidden object and it doesn't count.
        ld a, h
        or l
        jr z, item_not_present_loop

        xor a
        ret
item_not_present_loop:
        ; Move to the next entry
        add IX,DE
        djnz look_item_loop_test
        ld a, 0xff
        ret


;
; Helper function to return an item, by name.
;
; This is used a lot because the item-entries contain a series of
; pointers for various purposes - handlers to be invoked for object-specific
; behaviour, the location of the object within our world-map, and
; a byte representing per-item state.
;
; On entry the name of the item to be found will be stored in HL.
;
; On exit A will be 00 if all is OK, and IX will point to the item.
; On exit A will be ff if there was a failure.
;
get_item_by_name:
        ; erase our temporary buffer, keeping the HL register
        ; with the name of the item to find safe.
        push hl
        ld hl, TMP_BUFFER
        ld b, TMP_BUFFER_LEN
        call erase_buffer
        pop hl

        ; copy the name of the item into the temporary-buffer
        ld de, TMP_BUFFER+1
        ld b,0
gibn_copy_loop:
        ld a,(hl)
        cp 0
        jr z, gibn_copy_complete
        ld (de),a
        inc de
        inc hl
        inc b
        jr gibn_copy_loop

gibn_copy_complete:
        ; prefix the temporary buffer with the length of the item
        ld hl, TMP_BUFFER
        ld (hl),b

        ; Point to our table of items
        ld ix, items
        ld b, ITEM_COUNT

gibn_item_loop:

        ; Get the name of the object in DE - that's at the start of the item.
        ld e,(IX)
        ld d,(IX + 1)

        ; Now get the location of the current object.
        ld a, (IX+ITEM_TABLE_LOCATION_OFFSET)

        ; Is this object carried?
        cp ITEM_CARRIED
        jr z, gibn_item_carried

        ; Is this object available (but hidden)?
        cp ITEM_INVISIBLE
        jr z, gibn_item_available

        ; Is this object in the current location?
        push hl
        ld hl, CURRENT_LOCATION
        ld c,(hl)
        pop hl

        cp c
        jr z, gibn_item_present

gibn_continue:
        ; OK we didn't find the object, so we need to try looking at
        ; the next table entry
        ld DE, ITEM_ENTRY_LENGTH
        add ix, DE
        djnz gibn_item_loop

        ; At this point we've looked at all objects in the table, and
        ; we didn't find a match.
        ld a, 0xff
        ret

gibn_item_present:
gibn_item_carried:
gibn_item_available:
        push bc ; preserve b for our loop

        ; OK we've found an item that is "present" or "available".
        ;
        ; Does this object have the name of the item we're actually
        ; supposed to be looking for?  If so then we've found it
        ; and we can return our IX register (which points to the
        ; start of the object in the item-table).
        ;
        ; If the name doesn't match we loop around to exmaine the
        ; next item in the table.
        ld hl, TMP_BUFFER ; Get the length from our buffer
        ld b, (hl)
        inc hl            ; Now HL points to the input
                          ; DE points to the name of the current item.
                          ; B contains the length
        call CompareStringsWithLength
        jp z, gibn_found_it

        pop bc
        jr gibn_continue

gibn_found_it:
        ; We found the item.  Drop the BC register, which we saved
        ; to preserve our loop-index.
        pop bc
        xor a
        ret


;
; Helper function.  Are we at risk of grue?
;
; If our location is in the dark-place we are at risk of being eaten.
;
; In the C implementation there was a random number test, here we decide
; that if you enter three valid turns within the dark place then you
; will die
;
maybe_grue_death:
        ; Are we in the dark-place?
        ld hl, CURRENT_LOCATION
        ld a,(hl)
        cp 4
        ret nz

        ; Get the grue (!)
        ld hl, item_15_name
        call get_item_by_name
        cp 0
        ret nz

        ; Once we've found the item IX will point to the entry
        ;
        ; Get the item state using that index register,
        ; after increasing it.
        inc  (IX + ITEM_TABLE_STATE_OFFSET)
        ld a,(IX + ITEM_TABLE_STATE_OFFSET)

        cp MAX_GRUE_EXPOSURE
        jr nc, death_by_grue_grue

        call show_dots
        ld de, grue_message
        call bios_output_string
        ret

death_by_grue_grue:
        ld de, you_were_eaten
        call bios_output_string

        ld hl,PLAYER_DEAD_FLAG
        inc (hl)

        call turns_function
        jp play_again
        ret

;
; Helper function.  Is the player carrying something?
;
; This is used in the inventory function to decide whether to show the list
; of items, with header, or "You're carrying nothing".
;
; Return "A == 0" if so.
; Return "A == FF" if not.
;
player_has_objects:
        ; Point to the item-table, and prepare to loop over the items
        ld IX, items
        ld DE, ITEM_ENTRY_LENGTH
        ld b, ITEM_COUNT

player_has_objects_loop:

        ; Get the location of the object in A.
        ld a,(IX+ITEM_TABLE_LOCATION_OFFSET)

        ; If the location is the player's posession we're carrying something,
        ; it doesn't matter what.
        cp ITEM_CARRIED
        jr nz, player_not_carrying_loop

        ; Report success
        xor a
        ret
player_not_carrying_loop:

        ; Point to the next entry.
        add IX, DE

        ; Loop again
        djnz player_has_objects_loop
        ld a, 0xff
        ret



;
; Helper function - get pointer to second command-line word
;
; e.g. The user enters "GET TORCH", "EXAMINE BOOK", etc, we want to
; get the start of second-word "TORCH", "BOOK"
;
input_second_term:
        ld hl, INPUT_BUFFER+2

        ; start by incrementing the pointer until we find a space
input_second_term_loop1:
        ld a,(hl)
        cp 0
        jp z,input_second_term_end
        cp ' '
        jp z, input_second_term_found_space
        inc hl
        jp input_second_term_loop1

        ; At this point HL points to " "
input_second_term_found_space:
        ld a,(hl)
        cp 0
        jp z,input_second_term_end
        cp ' '
        jp nz, input_second_term_found_word
        inc hl
        jp input_second_term_found_space

input_second_term_found_word:
        ; HL points to the word
        xor a
        ret

input_second_term_end:
        ld a, 0xff
        ret
; }}





;********************************************************************
; Command Handlers
;********************************************************************
; {{


;
; Command-Handler SWEARING
;
bad_language_function:
        ld de, BAD_LANGUAGE_MSG
        jp bios_output_string



;
; Command-Handler DOWN
;
; Change location, this has some tests to cope with the basement-puzzle.
;
down_function:
        ld hl, CURRENT_LOCATION
        ld a, (hl)
        cp 0
        jr z, down_on_top_floor
        cp 1
        jr z, down_on_middle_floor
        cp 2
        jr z, down_on_ground_floor

        ; fall-through - other options will show "NO DOWN"
no_down:
        ld de, no_down_msg
        call bios_output_string
        ret

down_on_top_floor:
down_on_middle_floor:
        inc (hl)
        call look_function
        ret

down_on_ground_floor:
        ; The trapdoor must be open for us to go down.
        ; Find the item, and get it's state.
        ld hl, item_11_name
        call get_item_by_name

        ; Once we've found the item IX will point to the entry
        ;
        ; Get the item state using the index register.
        ld a, (IX+ITEM_TABLE_STATE_OFFSET)

        cp TRAPDOOR_STATE_OPEN
        jr nz, no_down ; not open?  Then we can't go down

        ; Does the user have the (lit) torch?
        call user_has_lit_torch
        cp 0
        jr z, dark_destination

        ; OK the user does have it, we can move to the basement
        ld hl, CURRENT_LOCATION
        ld (hl),3
        call look_function
        ret
dark_destination:
        ; user doesn't have lit torch - goes to the dark place
        ld hl, CURRENT_LOCATION
        ld (hl),4
        call look_function
        ret



;
; Does the user have the torch, which is lit?
;
; Return 1 if the user does.
;
; Return 0 if the torch is unlit, or not carried.
user_has_lit_torch:
        ; get the torch
        ld hl, item_3_name
        call get_item_by_name

        ; Once we've found the item IX will point to the entry
        ;
        ; Get the location using the index register.
        ld a, (IX+ITEM_TABLE_LOCATION_OFFSET)

        ; Are we carrying the item?
        cp ITEM_CARRIED
        jr nz, user_not_got_torch

        ; OK now see if the torch is lit
        ld a, (IX+ITEM_TABLE_STATE_OFFSET)

        ; Is it lit?
        cp TORCH_STATE_LIT
        jr nz, user_got_torch_but_not_lit

        ; OK the user has a torch, and it is lit
        ld a,1
        ret

user_not_got_torch:
user_got_torch_but_not_lit:
        xor a
        ret


;
; Command-Handler DROP
;
; If the item is carried by the player it is dropped
;
; If there is a non-zero drop-function it is invoked.
;
drop_function:
        call input_second_term
        cp 0
        jp z, drop_object

        ld de, DROP_WHAT_MSG
        call bios_output_string
        ret

drop_object:
        ; store object in HL
        call input_second_term

        call get_item_by_name
        cp 0
        jp z,drop_found_it

        ; if we didn't find it in the current location or inventory
        ; then we're not carrying it.
        ld de, not_carrying_item_msg
        call bios_output_string
        ret

drop_found_it:
        ; IX points to the item's table-entry

        ; Get the current location
        ld hl, CURRENT_LOCATION
        ld a,(hl)

        ; Update the item to have its location-field set to the
        ; location we just discovered.
        ld (IX + ITEM_TABLE_LOCATION_OFFSET),a

        ; IX still points to the start of the item's entry,
        ; now look for a custom drop-function.
        ld l, (IX+ITEM_TABLE_DROP_OFFSET)
        ld h, (IX+ITEM_TABLE_DROP_OFFSET+1)

        ; is the handler empty?
        ld a, l
        or h
        jr nz, drop_invoke_handler
        ld de, you_drop_it
        call bios_output_string
        ret

drop_invoke_handler:
        ; jump to the handler, the ret at the end
        ; of that handler will return here.
        jp JP_HL





;
; Command-Handler EXAMINE
;
; Examine either:
;
;   1.  An item in the current location.
;
;   2.  An item in the users' inventory.
;
; Examination means:
;
;   1.  Identify the object from the input-buffer
;   2.  Check if the object exists, and if so
;   3.  Show the extended-description
;
examine_function:
        call input_second_term
        cp 0
        jp z, examine_object

        ld de, EXAMINE_WHAT_MSG
        call bios_output_string
        ret

examine_object:
        call show_newline

        ; store object in HL
        call input_second_term

        call get_item_by_name
        cp 0
        jp z,examine_found_it

        ld de, item_not_present_msg
        call bios_output_string
        ret

examine_found_it:

        ; IX points to the start of the entry for the object.
        ;
        ; Find the name of the custom examine-handler, if any, using
        ; the index-register.
        ld l,(IX+ITEM_TABLE_EXAMINE_OFFSET)
        ld h,(IX+ITEM_TABLE_EXAMINE_OFFSET+1)

        ; If the custom examine function is non-empty call
        ; it and return, otherwise show the extended message
        ld a, l
        or h
        jr z, show_ext_desc

        ; The ret at the end of that handler will return
        ; from this function.
        jp JP_HL


show_ext_desc:
        ; get the location of the extended-description pointer
        ld e, (IX+ITEM_TABLE_EXT_DESCRIPTION_OFFSET)
        ld d, (IX+ITEM_TABLE_EXT_DESCRIPTION_OFFSET+1)

        ; show it and return
        call bios_output_string
        ret





;
; Command-Handler GO
;
; This allows the user to enter "GO UP", and "GO DOWN".
;
go_function:
        call input_second_term
        cp 0
        jp z, go_somewhere

go_unknown:
        ld de, GO_WHERE_MSG
        call bios_output_string
        ret

go_somewhere:

        ; GO "U" vs GO "D"
        ld a,(HL)
        cp 'U'
        jr z, up_function_jmp
        cp 'D'
        jr z, down_function_jmp

        ; not (u)p or (d)own - show error
        jr go_unknown

        ; Relative jumps only allow the range +127/-127 bytes
        ; so we've had to add absolute jumps here.
down_function_jmp:
        jp down_function
up_function_jmp:
        jp up_function


;
; Command-Handler CALL
;
; If we're in the middle-floor we can use the telephone
;
call_function:
        ld hl, CURRENT_LOCATION
        ld a,(hl)
        cp 1
        jr z, call_proceed

        ; not in the phone-room?  Show an error and return
        ld de, NO_PHONE_HERE
        call bios_output_string
        ret

call_proceed:
        call input_second_term
        cp 0
        jp z, call_person

        ; missing person
        ld de, CALL_WHO_MSG
        call bios_output_string
        ret

call_person:
        ; HL points to the person the user tried to call
        ; look in our people-table to see if there is a response
        ; we can make
        ld de, people_table
next_person_test:
        push de
        ld a, (de)       ; length of string
        cp 0x00          ; zero?  We've hit the end of the table and not found
        jr nz, cont_call ; a match - show a failure message and return

        ; show the error-message and return
        pop de
        ld de, call_unknown_msg
        call bios_output_string
        ret

        ; OK we've got an entry
cont_call:
        ld b, a    ; B will contain the length
        inc de     ; DE point to the string itself

        push hl
        call CompareStringsWithLength
        jp z, found_person_to_call
        pop hl

        ; ok we didn't find
        pop de

        ; ok we didn't find
        ld a, (de)
        inc de     ; get the entry-length
        ld b,a
skip_string:
        inc de
        djnz skip_string
        inc de ; addr1
        inc de ; addr2
        jp next_person_test

found_person_to_call:
        pop hl
        pop de
        ld a, (de)
        inc de     ; get the entry-length
        ld b,a
skip_string2:
        inc de
        djnz skip_string2
        push de
        pop hl
        ld e, (hl)
        inc hl
        ld d, (hl)
        call bios_output_string
        ret

;
; Command-Handler GET
;
;  If there is a custom take-function defined for the appropriate
; object then we'll invoke it.
;
;  Otherwise the location of the item will be updated to mark it as
; within the player's inventory.
;
get_function:
        call input_second_term
        cp 0
        jp z, get_object

        ld de, GET_WHAT_MSG
        call bios_output_string
        ret

get_object:
        ; store object in HL
        call input_second_term

        call get_item_by_name
        cp 0
        jp z,get_found_it

        ld de, item_not_present_msg
        call bios_output_string
        ret

get_found_it:
        ; IX points to the start of the entry for the object.
        ;
        ; Find the name of the custom take-handler, if any, using
        ; the index-register.
        ld l, (IX+ITEM_TABLE_TAKE_OFFSET)
        ld h, (IX+ITEM_TABLE_TAKE_OFFSET+1)

        ; Is there a custom function?
        ld a, h
        or l
        jr z, take_as_normal

        ; OK there is a custom function.  Use it
        call JP_HL
        ret

take_as_normal:

        ; Get the collectable property of the object, using
        ; the index register.
        ld a, (IX+ITEM_TABLE_COLLECTABLE_OFFSET)

        ; is this item collectable?
        cp 1
        jr z, get_found_it_take

        ld de, cant_take_that_msg
        call bios_output_string
        ret

get_found_it_take:

        ; Change the location of the object to be within the
        ; players possession.
        ld (IX+ITEM_TABLE_LOCATION_OFFSET),ITEM_CARRIED

        ; Now we've taken the item show the users (updated)
        ; inventory.
        call inventory_function
        ret




;
; Make trapdoor visible is called when the rug is taken/examined.
;
; The trapdoor has three states:
;
;  invisible, open, closed
;
; If the current state is invisible then we mark it as visible.

make_trapdoor_visible:
        ld hl, item_11_name
        call get_item_by_name
        cp 0
        jp z, place_trapdoor

        ld de, failed_find_trapdoor_msg
        call bios_output_string
        ret

place_trapdoor:
        ; We set the location of the trapdoor to being the
        ; current location.
        ;
        ; NOTE: We could just hardcode this to location "3".
        ;
        ; Get the current location.
        ld hl, CURRENT_LOCATION
        ld a, (hl)

        ; Save the location in the item.
        ld (IX+ITEM_TABLE_LOCATION_OFFSET),a

        ; Update the state
        ld a, TRAPDOOR_STATE_CLOSED
        ld (IX+ITEM_TABLE_STATE_OFFSET), a
        ret



;
; Command-Handler HELP
;
; Show "These commands are available", then the names of each non-hidden
; command.
;
help_function:
        ld de, HELP_MSG
        call bios_output_string
        ld de,command_table
help_function_again: ; have we run out of commands?
        ld a, (de) ; length of string
        cp 0x00
        ret z
        ld hl, TMP_BUFFER
        ld b, a    ; B will contain the length
        inc de     ; DE point to the string itself
help_func_loop:  ; copy the command-name to the buffer
        ld a,(de)
        ld (hl),a
        inc hl
        inc de
        djnz help_func_loop
        ld a, 0x0a
        ld (hl),a
        inc hl
        ld a, 0x0d
        ld (hl),a
        inc hl
        ld a, '$'
        ld (hl),a
        push de
        ld a,(de)
        cp 1
        jr z, help_skip_this
        call show_tab
        ld de, TMP_BUFFER
        call bios_output_string

help_skip_this:
        pop de
        inc de  ; skip hidden-flag
        inc de  ; skip addr1
        inc de  ; skip addr2
        jp  help_function_again



;
; Command-handler INVENTORY
;
inventory_function:
        call player_has_objects         ; is the player carrying:
        cp 0
        jp z, inventory_show_items      ; Yes.  Go show

        ld de,inventory_empty_message   ; Otherwise "Carrying nothing"
        call bios_output_string
        ret

inventory_show_items:
        ld de,you_carrying_message
        call bios_output_string

        ;
        ; We know there are items being carried, so now we'll loop
        ; over them and print them out appropriately.
        ;
        ld IX, items
        ld DE, ITEM_ENTRY_LENGTH
        ld b, ITEM_COUNT
inventory_test_item:

        ; Get the location of the object.
        ld a, (IX+ITEM_TABLE_LOCATION_OFFSET)

        ; Is this carried?
        cp ITEM_CARRIED
        jr nz, inv_item_not_carried

        ; OK the item is carried, show it out.
        PUSH_ALL

          ; Show a tab
          call show_tab

          ; show the item
          ld e,(IX + ITEM_TABLE_DESCRIPTION_OFFSET)
          ld d,(IX + ITEM_TABLE_DESCRIPTION_OFFSET+1)
          call bios_output_string

          ; then a newline
          call show_newline
        POP_ALL

inv_item_not_carried:
        ; bump to the next item
        add ix,de
        djnz inventory_test_item
        ret



;
; Command-Handler WRAP
;
; We're called with an argument which is numeric
;
wrap_function:
        call input_second_term
        cp 0
        jp z, wrap_handle_argument
show_wrap:
        ; show the message
        ld de, WRAP_IS_MSG
        call bios_output_string

        ld hl, WRAP_LOCATION
        ld a, (hl)
        call show_a_register

        call show_newline
        ret

wrap_handle_argument:
        push hl
        pop de
        call string_to_uint16
        push hl
        pop de
        ld hl, WRAP_LOCATION
        ld (hl),e
        jr show_wrap


;
; Command-Handler LOOK
;
; Show the current location.  If the seen-flag has not been set then
; show the long description and set the flag.
;
; There is a special case here to handle the case where the user types
;
;   LOOK AT XXX
;
; If we see "LOOK AT XXX" then we replace the command with "EXAMINE YYYY"
;
look_function:

        ld de, LOOK_AT                ;; "LOOK AT "
        ld b, 7                       ;; strlen("LOOK_AT ")
        ld hl, INPUT_BUFFER+2
        call CompareStringsWithLength
        jp nz,look_at_environment

        ; OK we have a sleazy hack here.
        ;
        ; We want to convert:
        ;
        ;   "LOOK AT PIE"
        ;
        ; to
        ;
        ;   "EXAMINE PIE"
        ;
        ; Happily the length of "LOOK AT" is the same as the length of
        ; EXAMINE.
        ;
        ; Edit the input-buffer in-place
        ld hl, INPUT_BUFFER+2
        ld (hl), "E"
        inc hl
        ld (hl), "X"
        inc hl
        ld (hl), "A"
        inc hl
        ld (hl), "M"
        inc hl
        ld (hl), "I"
        inc hl
        ld (hl), "N"
        inc hl
        ld (hl), "E"
        inc hl
        ld (hl), " "

        jp examine_function

look_at_environment:
        ld de,LOOK_FUNCTION_PREFIX
        call bios_output_string
        ld hl, CURRENT_LOCATION
        ld b,(hl)
        ld c, LOCATION_ENTRY_LENGTH
        call multiply
        ld de, location_table ; add to base of location table
        add hl,de

look_function_show:
        ; ok we point to the table - show the short version
        ld e, (hl)
        inc hl
        ld d, (hl)
        inc hl
        push hl
        call bios_output_string
        call show_newline
        call show_newline
        pop hl

        ld e, (hl)  ; get the long-message address in de
        inc hl
        ld d, (hl)
        inc hl

        ; input-buffer starts with L for look?
        ; then always show
        ld bc, INPUT_BUFFER+2
        ld a, (bc)
        cp 'L'
        jp z,look_show_extended

        ; otherwise if we've seen this room don't show the
        ; extended description or objects.
        ld a, (hl)
        cp 1
        ret z
look_show_extended:
        push hl
        call bios_output_string
        pop hl

        ld a, 1
        ld (hl), a    ; set the seen-flag


        ; If no items are in this room we can return
        call items_are_present
        cp 0
        ret nz

        ; Show "You see .."
        ld de,you_see_message
        call bios_output_string

        ;
        ; OK at this point we have looked at the room, and
        ; we want to see the items there.
        ;
        ; Walk over the list of items - and show any which
        ; are present in this room.
        ;
        ld IX, items
        ld b, ITEM_COUNT

look_item_loop:

        ; Get the location of the object.
        ld c, (IX+ITEM_TABLE_LOCATION_OFFSET)

        ; Get the current location
        push hl
        ld hl, CURRENT_LOCATION
        ld a,(hl)
        pop hl

        ; If the location of the object doesn't match it isn't here.
        cp c
        jr nz, item_not_present

        ; Get the description of the object in DE
        ld e,(IX+ITEM_TABLE_DESCRIPTION_OFFSET)
        ld d,(IX+ITEM_TABLE_DESCRIPTION_OFFSET+1)

        ; Is the description empty?  Then the item is hidden.
        ld a, d
        or e
        jr z, item_not_present

        PUSH_ALL
          call show_tab
          call bios_output_string
          call show_newline
        POP_ALL
item_not_present:
        ; Since we have HL pointing to an entry we can move to the next
        ; just by adding the length of the table-item.
        ld de, ITEM_ENTRY_LENGTH
        add IX,de
        djnz look_item_loop
        ret




;
; Command-handler MAGIC
;
; Show a different message each time this is called, until you are killed.
;
magic_function:
        ld hl, MAGIC_COUNT
        ld a,(hl)
        inc a
        ld (hl),a

        cp 1
        jr z, magic_one

        cp 2
        jr z, magic_two

        cp 3
        jr z, magic_three

        ; magic four
        ld de, magic_four_msg
        call bios_output_string

        ; you're dead
        ld hl, PLAYER_MAGIC_OVERDOSE_FLAG
        inc (hl)
        ret
magic_one:
        ld de, magic_one_msg
        call bios_output_string
        ret
magic_two:
        ld de, magic_two_msg
        call bios_output_string
        ret
magic_three:
        ld de, magic_three_msg
        call bios_output_string
        ret




;
; Command-Handler QUIT
;
; Terminate the game, and show the turn-count.
;
quit_function:
        ld de, QUIT_MSG
        call bios_output_string
        call turns_function
        jp play_again


;; 6. Bios test of wrapped text
bios_text_wrap_test:
        call bios_clear_screen
        ld hl, WRAP_LOCATION
        ld a, (hl)
        push af
        ld (hl), 10
        ld de, bios_wrap_test_message
        call bios_output_string
        pop af
        ld (hl), a
        jr pause_for_key_indirect



bios_delay_test:
        ; 4. delay test
        call bios_clear_screen
        ld de, delay_test_message
        call bios_output_string
        ld b, 30
delay_loop:
        PUSH_ALL
         call bios_delay
         ld e, '.'
         call bios_output_character
        POP_ALL
        djnz delay_loop
        jr pause_for_key_indirect


;; 7.  bios dump of size
bios_size_dump:
        call bios_clear_screen
        ld de, bios_size_dump_code
        call bios_output_string
        ld hl, WRAP_LOCATION - ENTRYPOINT
        call DispHL

        ld de, bios_size_dump_text
        call bios_output_string
        ld hl, end_of_source - WRAP_LOCATION
        call DispHL

        ld de, bios_size_dump_total
        call bios_output_string
        ld hl, end_of_source - ENTRYPOINT
        call DispHL

pause_for_key_indirect:
        jr pause_for_key

;
; Command-handler: BIOS
;
bios_function:
        ; clear the screen & show the menu text
        call bios_clear_screen
        ld de, BIOS_MSG
        call bios_output_string
bios_function_menu:
        ; wait for a keypress
        call bios_await_keypress
        ; process the responses
        cp '1'
        jr z, bios_function_clear
        cp '2'
        jr z, bios_show_character
        cp '3'
        jr z, bios_input_test
        cp '4'
        jr z, bios_delay_test
        cp '5'
        jr z, bios_char_display
        cp '6'
        jr z, bios_text_wrap_test
        cp '7'
        jr z, bios_size_dump
        cp '8'
        jr z, bios_return_to_game_indirect
        cp 'q'
        jr z, bios_return_to_game_indirect
        jr bios_function_menu

bios_function_clear:
        ; 1. Clear screen
        call bios_clear_screen
        jr bios_function

bios_show_character:
        ; 2. Show a character
        ld e, '*'
        call bios_output_character
        jr bios_function_menu

bios_input_test:
        ; 3. Input test
        call bios_clear_screen

        ; show the input-prompt
        ld de, input_test_message
        call bios_output_string

        ; read a line of text
        ld de, INPUT_BUFFER
        call bios_read_input

        ; get the amount of text entered
        ld hl, INPUT_BUFFER+1
        ld a,(hl)

        ; zero?
        cp 0
        jr nz, show_input_buffer
        ld de, no_input
        call bios_output_string
        jr pause_for_key
show_input_buffer:
        ; ok user entered something, get the length in B
        ld hl, INPUT_BUFFER
        inc hl
        ld b, (hl)
skip_forward:
        inc hl
        djnz skip_forward
        inc hl
        ; terminate the buffer with '$'
        ld (hl), '$'

        ; now show the prompt, and the users' input
        ld de, you_entered_message
        call bios_output_string
        ld de, INPUT_BUFFER+2
        call bios_output_string
pause_for_key:
        ld de, press_key_continue
        call bios_output_string
        call bios_await_keypress
bios_function_indirect:
        jr bios_function


; work around the fact that our handler is too far away for a relative jump.
bios_return_to_game_indirect:
        jr bios_return_to_game

bios_char_display:
        ; 5. character code display
        call bios_clear_screen
        ld de, press_key_continue
        call bios_output_string

        ; Await a keypress, and save it
        call bios_await_keypress
        push af

        ; show explaination
        ld de,you_pressed
        call bios_output_string

        ; show decimal keycode
        call show_a_register

        ; and the character itself
        ld e, " "
        call bios_output_character
        ld e, "<"
        call bios_output_character
        pop af
        ld e,a
        call bios_output_character
        ld e, ">"
        call bios_output_character

        jr pause_for_key


bios_return_to_game:
        ; 6. return to game
        call bios_clear_screen
        FAKE_LOOK
        ret

;
; Command-Handler SLEEP
;
sleep_function:

       ld de, SLEEP_START_MSG
       call bios_output_string
       call show_dots

       ; Double the turn-count.  (Cruel!)
       ld hl,TURN_COUNT
       ld a, (hl)
       add a, a
       ld (hl),a

       ld de, SLEEP_END_MSG
       call bios_output_string
       ret


;
; Command-Handler TURNS
;
; Show the number of turns a user has played
;
turns_function:
        call show_newline
        ld de, PLAYER_TURN_COUNT
        call bios_output_string
        ld hl, TURN_COUNT
        ld a, (hl)
        call show_a_register
        ld de, PLAYER_TURN_COUNT_END
        call bios_output_string
        ret



;
; Command-Handler USE
;
; Use the named object, if there is a handler defined for it.
use_function:
        call input_second_term
        cp 0
        jp z, use_object

        ld de, USE_WHAT_MSG
        call bios_output_string
        ret

use_object:
        ; store object in HL
        call input_second_term

        ; find the object
        call get_item_by_name
        cp 0
        jp z, use_found_object

        ; the object was not found
        ld de, item_not_present_msg
        call bios_output_string
        ret

use_found_object:

        ; IX points to the start of the entry for the object.
        ;
        ; Find the name of the custom use-handler, if any, using
        ; the index-register.
        ld l, (IX+ITEM_TABLE_USE_OFFSET)
        ld h, (IX+ITEM_TABLE_USE_OFFSET+1)

        ; is the use-handler empty?
        ld a, h
        or l
        jr z, use_is_futile

        ; jump to the use-handler, the ret at the
        ; end of that function will return from this handler
        jp JP_HL

use_is_futile:
        ld de, use_generic
        call bios_output_string
        ret




;
; Command-Handler UP
;
; Change location.  Up is possible if you're not on the top-floor.
;
; When in the dark room "UP" moves you up two places.
;
up_function:
        ld hl, CURRENT_LOCATION
        ld a, (hl)
        cp 0
        jr z, no_up                ; can't go up
        cp 1
        jr z, up_on_middle_floor   ; go up - possible victory condition
        cp 2
        jr z, up_on_ground_floor   ; go up
        cp 3
        jr z, up_on_basement_floor ; go up
        cp 4
        jr z, up_on_dark_room      ; go up two - to land in ground floor

up_on_middle_floor:
        ; Get the meteor?
        ld hl, item_13_name
        call get_item_by_name

        ; Get the location of the meteor.
        ld a, (IX + ITEM_TABLE_LOCATION_OFFSET)

        ; Are we carrying it ?
        cp ITEM_CARRIED
        jr nz, up_on_ground_floor

        ; We're on the middle-floor, going up, carrying the meteor.
        ; That's an easy victory.
        ld hl, PLAYER_WON_FLAG
        inc (hl)

        ; Show the successful result
        ld de, meteor_saves_the_day
        call bios_output_string
        ret

no_up:
        ld de, no_up_msg
        call bios_output_string
        ret

up_on_dark_room:
        ld hl, CURRENT_LOCATION
        dec (hl)
            ; fall-through

up_on_ground_floor:
up_on_basement_floor:
        ld hl, CURRENT_LOCATION
        dec (hl)
        call look_function
        ret


show_newline:
        ld de, NEWLINE
        jp bios_output_string

show_tab:
        PUSH_ALL
        ld de, TAB
        call bios_output_string
        POP_ALL
        ret


;
; Command-Handler WAIT
;
; Nothing happens.
;
wait_function:
        ld de, WAIT_CMD_MSG
        call bios_output_string
        ret

; }}



;********************************************************************
; CUSTOM OBJECT HOOKS
;********************************************************************
; {{

;  When you drop the mirror it cracks.
;
;  Move the "mirror" item to the current location, as per-usual,
; but also update the item-name and expanded description.
;
;  We record that we've broken it in the item-state, so only dropping
; it the first time triggers this behaviour.
drop_mirror_fn:
        ; find the mirror
        ld hl, item_1_name
        call get_item_by_name

        ; Once we've found the item IX will point to the entry
        ;
        ; Change the location to the current one
        ld hl, CURRENT_LOCATION
        ld a,(hl)
        ld (IX + ITEM_TABLE_LOCATION_OFFSET), a

        ; Was the mirror already dropped?
        ld a,(IX + ITEM_TABLE_STATE_OFFSET)
        cp MIRROR_BROKEN
        jr nz, drop_mirror_break_it

        ; OK the mirror was already broken, so we don't
        ; need to do anything special.  Just say "You drop it"
        ; and return.
        ld de,you_drop_it
        call bios_output_string
        ret

drop_mirror_break_it:
        ; Update the state to record that it was broken.
        ld (IX + ITEM_TABLE_STATE_OFFSET), MIRROR_BROKEN

        ; change the description
        ld de, item_1_desc_broken
        ld hl, item_first_desc
        ld (hl), e
        inc hl
        ld (hl), d

        ; change the extended description
        ld de, item_1_long_broken
        ld hl, item_first_edesc
        ld (hl), e
        inc hl
        ld (hl), d

        ; Show the drop message
        ld de, MIRROR_DROP_FUN
        call bios_output_string
        ret


; When you EXAMINE ROOM you'll end up here
examine_room_fn:
        FAKE_LOOK
        ret

; When you EXAMINE RUG you'll end here.
;
;  If the rug is on the ground:
;    show the user a message and
;    make the trapdoor appear
;
;  If the rug is in your posession just show the description
examine_rug_fn:

        ; Get the rug object
        ld hl, item_7_name
        call get_item_by_name

        ; Get the location which it appears
        ld a,(IX+ITEM_TABLE_LOCATION_OFFSET)

        ; Is the item in your possessions?
        cp ITEM_CARRIED
        jr nz, rug_on_ground

        ; The rug must be in your possession, just show the extended
        ; description.
        ld e, (IX+ITEM_TABLE_EXT_DESCRIPTION_OFFSET)
        ld d, (IX+ITEM_TABLE_EXT_DESCRIPTION_OFFSET+1)
        call bios_output_string

        ret

rug_on_ground:

        ld de, rug_detail_msg
        call bios_output_string
        call make_trapdoor_visible
        ret



; When you EXAMINE DESK you might find a meteor.
;
;  If the meteor is hidden
;   it will become visible
;
;  Otherwise you just see the desk.
;
examine_desk_fn:

        ; Get the meteor item
        ld hl, item_13_name
        call get_item_by_name

        ; Get the state of the meteor
        ld a, (IX+ITEM_TABLE_STATE_OFFSET)

        ; If the state of the meteor is hidden, then show it
        cp 0
        jr z, meteor_hidden

        ld de, item_9_long
        call bios_output_string
        ret

meteor_hidden:

        ; Update the state of the desk to show we've examined it
        ld (IX+ITEM_TABLE_STATE_OFFSET), 1

        ; desk description
        ld de, item_9_long
        call bios_output_string

        ; desk addendum
        ld de, desk_has_meteor
        call bios_output_string
        ret



;
;  When you TAKE the meteor it only works if the item-state is 1
;
;  This is set by examine desk
;
take_meteor_fn:
        ; Get the meteor item
        ld hl, item_13_name
        call get_item_by_name

        ; Get the state of the meteor - we must have discovered
        ; it by examining the desk before we can take it.
        ld a, (IX + ITEM_TABLE_STATE_OFFSET)

        ; State is 0?
        cp 0
        jr nz, take_meteor

        ld de,item_not_present_msg
        call bios_output_string
        ret

take_meteor:
        ; update the object location to be in the player's posession
        ld (IX + ITEM_TABLE_LOCATION_OFFSET), ITEM_CARRIED

        ; Now we've taken the item show the users (updated)
        ; inventory.
        call inventory_function
        ret


;  When you TAKE the RUG a trapdoor will be revealed:
;
;  - If it was already hidden
;
;  - AND you're in the basement
;
take_rug_fn:

        ; Get the rug object
        ld hl, item_7_name
        call get_item_by_name

        ; Move the rug into the player's possession.
        ld (IX+ITEM_TABLE_LOCATION_OFFSET),ITEM_CARRIED

        ; Taking the rug should only trigger this behaviour once.
        ;
        ; Since we have a piece of state with each object we can use that.
        ld a, (IX + ITEM_TABLE_STATE_OFFSET)

        ; If the state contains non-zero we've done this
        ; before so we just show the inventory as we would
        ; for a normal "take xxx" action.
        cp 0
        jr nz, get_rug_show_inv

        ; Store 1 in the state, so we don't do this again.
        ld (IX + ITEM_TABLE_STATE_OFFSET),1

        ; Is the trapdoor already present?  If so we don't need
        ; to do anything special.

        ; get the trapdoor
        ld hl, item_11_name
        call get_item_by_name

        ; Get the location of the object in A
        ld a, (IX+ITEM_TABLE_LOCATION_OFFSET)

        ; trapdoor in the basement?  No special action required
        cp 2
        jr z, get_rug_show_inv

        ; show a message telling the user about the trapdoor.
        ld de, rug_taken_msg
        call bios_output_string

        ; And make the trapdoor visible
        call make_trapdoor_visible
        ret

get_rug_show_inv:
        call inventory_function
        ret


; When you USE the book it shows you contents
;
; This is invoked by:
;
;   READ [THE] BOOK
;   OPEN [THE] BOOK
;   USE  [THE] BOOK
use_book_fn:

        call show_newline

        ; find the book
        ld hl, item_8_name
        call get_item_by_name

        ; Get the extended description
        ld e,(IX+ITEM_TABLE_EXT_DESCRIPTION_OFFSET)
        ld d,(IX+ITEM_TABLE_EXT_DESCRIPTION_OFFSET+1)

        ; show it
        call bios_output_string
        ret


;  When you USE the TORCH it lights.
;
;  This means updating the item-state to have the LIT attribute
;
use_torch_fn:
        ; find the torch
        ld hl, item_3_name
        call get_item_by_name

        cp 0
        jp z,use_torch_found_t

        ld de, failed_find_torch_msg
        call bios_output_string
        ret
use_torch_found_t:

        ; The item-table entry will be stored in HL and IX
        ; Get the state in A
        ld a, (IX+ITEM_TABLE_STATE_OFFSET)

        cp TORCH_STATE_UNLIT
        jr z, torch_was_off
        cp TORCH_STATE_LIT
        jr z, torch_was_on

        ld de, torch_bogus_state_msg
        call bios_output_string
        ret

torch_was_off:
        ; update state
        ld (IX+ITEM_TABLE_STATE_OFFSET), TORCH_STATE_LIT

        ; update the description
        ld hl, torch_item_desc
        ld de, item_3_desc_on
        ld (hl), e
        inc hl
        ld (hl), d

        ld hl, torch_item_long
        ld de, item_3_long_on
        ld (hl), e
        inc hl
        ld (hl), d

        ; show message
        ld de, TORCH_ON_MSG
        call bios_output_string

        ; If you're in the dark-place we'll now warp you to the
        ; normal basement.
        ld hl, CURRENT_LOCATION
        ld a,(hl)
        cp 4
        jr nz, out_of_here
        ld (hl),3

        ; show that you can see where you are
        ld de,NOW_YOU_SEE
        call bios_output_string

        ; show the location
        FAKE_LOOK

out_of_here:
        ret


torch_was_on:
        ; update state
        ld (IX+ITEM_TABLE_STATE_OFFSET), TORCH_STATE_UNLIT

        ; update the description
        ld hl, torch_item_desc
        ld de, item_3_desc_off
        ld (hl), e
        inc hl
        ld (hl), d

        ld hl, torch_item_long
        ld de, item_3_long_off
        ld (hl), e
        inc hl
        ld (hl), d

        ; show the message
        ld de, TORCH_OFF_MSG
        call bios_output_string
        ret


;  When you OPEN the TRAPDOOR it opens.
;
;  Find the trapdoor, and update the state to be "OPEN".
;
use_trapdoor_fn:
        ; find the trapdoor
        ld hl, item_11_name
        call get_item_by_name

        ; get the state offset
        ld a,(IX+ITEM_TABLE_STATE_OFFSET)

        ; update the state to be open
        cp TRAPDOOR_STATE_INVISIBLE
        jr nz, not_invisible

        ld de, item_not_present_msg
        call bios_output_string
        ret
not_invisible:
        cp TRAPDOOR_STATE_CLOSED
        jr z, trapdoor_was_closed
        cp TRAPDOOR_STATE_OPEN
        jr z, trapdoor_was_open

        ; bug
        ld de,trapdoor_bogus_state_msg
        call bios_output_string
        ret

trapdoor_was_closed:
        ; change the state
        ld (IX+ITEM_TABLE_STATE_OFFSET), TRAPDOOR_STATE_OPEN

        ; update the description
        ld hl, trapdoor_desc
        ld de, item_11_open
        ld (hl),e
        inc hl
        ld (hl),d
        ld hl, trapdoor_edesc
        ld de, item_11_desc_open
        ld (hl),e
        inc hl
        ld (hl),d

        ; Show the message
        ld de, TRAPDOOR_OPEN_MSG
        call bios_output_string
        ret

trapdoor_was_open:
        ; change the state
        ld (IX+ITEM_TABLE_STATE_OFFSET), TRAPDOOR_STATE_CLOSED

        ; update the description
        ld hl, trapdoor_desc
        ld de, item_11_closed
        ld (hl),e
        inc hl
        ld (hl),d
        ld hl, trapdoor_edesc
        ld de, item_11_desc_closed
        ld (hl),e
        inc hl
        ld (hl),d

        ; Show the message
        ld de, TRAPDOOR_CLOSED_MSG
        call bios_output_string
        ret




;  When you USE the GENERATOR you win.
;
use_generator_fn:
        ; find the generator
        ld hl, item_0_name
        call get_item_by_name

        cp 0
        jp z,use_generator_found_t

        ld de, failed_find_generator_msg
        call bios_output_string
        ret

use_generator_found_t:

        ; You can only win if the generator is used on the top-floor
        ld hl, CURRENT_LOCATION
        ld a,(hl)
        cp 0
        jr z, use_generator_won_fn

        ld de, use_gen_location
        jr print_and_return
use_generator_won_fn:
        ld hl, PLAYER_WON_FLAG
        ld (hl),1

        ld de, use_generator_won
print_and_return:
        call bios_output_string
        ret

; }}

include "bios.z80"





;********************************************************************
; Data / State Storage
;********************************************************************
; {{
WRAP_LOCATION:
IF SPECTRUM
  WRAP_WIDTH: DB 50
ELSE
  WRAP_WIDTH: DB 60
ENDIF
per_game_state_start:
TURN_COUNT:
        db 0         ; count of turns
CURRENT_LOCATION:
        db 0         ; offset into location table
PLAYER_MAGIC_OVERDOSE_FLAG:
        db 0         ; 1 iff the player overdosed on magic.
PLAYER_DEAD_FLAG:
        db 0         ; 1 iff player is dead
PLAYER_WON_FLAG:
        db 0         ; 1 iff player has won
MAGIC_COUNT:
        db 0         ; state for magic-function
SHIP_WARNING:
        db 0         ; State for showing a "ship closer" message.
; }}


;********************************************************************
; String Area
;********************************************************************
; {{
call_911_msg:
call_999_msg:
call_police_msg:
        db 0x0a, 0x0d, "Unfortunately Mayor Goodway's budget mishandling have resulted "
        db "in a lack of a functioning police force.", 0x0a, 0x0d
        db 0x0a, 0x0d, "The best you can do is call a bunch of dogs, and their teenaged handler.", 0x0a, 0x0d, "$"
call_unknown_msg:
        db 0x0a, 0x0d, "I'm sorry I don't know who that is.", 0x0a, 0x0d, "$"
call_ghostbusters_msg:
        db 0x0a, 0x0d, "Who you gonna call?  Really?", 0x0a, 0x0d, "$"
call_ryder_msg:
        db 0x0a, 0x0d, "Ryder here!  No pup is too small, no job is too big!", 0x0a, 0x0d
        db 0x0a, 0x0d, "Please leave a message after the beep, and I'll get back to you soon!"
        db 0x0a, 0x0d, 0x0a, 0x0d, "Sorry!", 0x0a, 0x0d, "$"
call_skye_msg:
        db 0x0a, 0x0d, "Skye responds quickly, but over the sound of air roaring down the phone you "
        db "cannot hear what she's saying.", 0x0a, 0x0d
        db "She must be a bit up in the air at the moment.", 0x0a, 0x0d, "$"
call_steve_msg:
        db 0x0a, 0x0d, "Steve doesn't publish his phone number.", 0x0a, 0x0d
        db 0x0a, 0x0d, "But emails to steve@steve.fi would be most welcome.", "$"
call_rubble_msg:
        db 0x0a, 0x0d, "Rubble doesn't answer your call.", 0x0a, 0x0d
        db 0x0a, 0x0d, "He's probably enjoying a nap.", 0x0a, 0x0d, "$"
call_me_msg:
        db 0x0a, 0x0d, "Debbie Harry says 'hello', before hanging up."
        ; FALL-THROUGH
NEWLINE:
        db 0x0a, 0x0d, "$"
TAB:
        db "     $"
invalid_msg:
        db 0x0a, 0x0d, "I did not understand your input.", 0x0a, 0x0d, 0x0a, 0x0d
        db "Enter 'HELP' to see some of our commands.", 0x0a, 0x0d, "$"
BAD_LANGUAGE_MSG:
        db 0x0a, 0x0d, "What language!", 0x0a, 0x0d, "$"
NO_PHONE_HERE:
        db 0x0a, 0x0d, "You can't see a telephone to use here!", 0x0a, 0x0d, "$"
magic_one_msg:
        db 0x0a, 0x0d, "Magic happens.",  0x0a, 0x0d, "$"
magic_two_msg:
        db 0x0a, 0x0d, "Magic intensifies.",  0x0a, 0x0d, "$"
magic_three_msg:
        db 0x0a, 0x0d, "The sensation of magic screaming through your veins gives you a heady rush. "
        db "This can't be good for you, maybe stop now?", 0x0a, 0x0d, "$"
magic_four_msg:
        db 0x0a, 0x0d , "You couldn't draw the line, could you?", 0x0a, 0x0d, 0x0a, 0x0d
        db "The magic flooding your body is too powerful, and you're finding it impossible "
        db "to breathe.  With a wail of frustration you topple backwards, clutching "
        db "at your chest.", 0x0a, 0x0d, 0x0a, 0x0d
        db "You're dying, soon the end will come.", 0x0a, 0x0d, 0x0a, 0x0d, "$"

CALL_WHO_MSG:
        db 0x0a, 0x0d, "Call who?", 0x0a, 0x0d, "$"
no_up_msg:
        db 0x0a, 0x0d, "You can't go up from here.", 0x0a, 0x0d, "$"
no_down_msg:
        db 0x0a, 0x0d, "You can't go down from here.", 0x0a, 0x0d, "$"
rug_taken_msg:
        db 0x0a, 0x0d, "You roll up the rug to make carrying it more straightforward, and as you do so "
        db "you notice that it was covering a trapdoor.", 0x0a, 0x0d, "$"
failed_find_torch_msg:
        db 0x0a, 0x0d, "BUG:Failed to find torch.", 0x0a, 0x0d, "$"
torch_bogus_state_msg:
        db 0x0a, 0x0d, "BUG:Bogus state for the torch", 0x0a, 0x0d, "$"
trapdoor_bogus_state_msg:
        db 0x0a, 0x0d, "BUG:Bogus state for the trapdoor", 0x0a, 0x0d, "$"
failed_find_trapdoor_msg:
        db 0x0a, 0x0d, "BUG:Failed to find trapdoor", 0x0a, 0x0d, "$"
rug_detail_msg:
        db 0x0a, 0x0d, "You examine the rug, which shows nothing special. "
        db "But while looking at the ground you notice that the rug covered a trapdoor.", 0x0a, 0x0d, "$"
TRAPDOOR_OPEN_MSG:
        db 0x0a, 0x0d, "The trapdoor opens, showing a murky set of steps leading downwards into shadow.", 0x0a, 0x0d, "$"
TRAPDOOR_CLOSED_MSG:
        db 0x0a, 0x0d, "The trapdoor is now closed, hopefully trapping the grue forevermore", 0x0a, 0x0d, "$"
failed_find_generator_msg:
        db 0x0a, 0x0d, "BUG:Failed to find the generator.", 0x0a, 0x0d, "$"
use_gen_location:
        db 0x0a, 0x0d, "You cannot see anywhere to connect the generator to."
        db 0x0a, 0x0d, "$"
use_generator_won:
        db 0x0a, 0x0d, "You connect the generator to the console, and turn it on.  With a steady thrum the generator begins to provide power.", 0x0a, 0x0d
        db "Success!  The main-light turns on! "
        db "The boat sees the light, and begins to execute a sharp turn to port, "
        db "it looks like it will make it."
        db 0x0a, 0x0d
        db "Congratulations, you will survive and so will the lighthouse!", 0x0a, 0x0d
        db "$"

meteor_saves_the_day:
        db 0x0a, 0x0d, "The glowing meteor you're carrying suddenly flares into an even brighter glow.", 0x0a, 0x0d
        db 0x0a, 0x0d
        db "The glow is almost blinding, and must surely be visible through the windows of "
        db "the lighthouse.  With a moment of inspiration you hold it above your head, and "
        db "it gets brighter still, the light arcing out over the sea in giant curved beam. "
        db "The boat sees the light, and begins to execute a sharp turn to port, "
        db "it looks like it will make it.", 0x0a, 0x0d
        db 0x0a, 0x0d
        db "Congratulations!", 0x0a, 0x0d
        db "$"
QUIT_MSG:
        db 0x0a, 0x0d, "You said 'QUIT' so we terminate!", 0x0a, 0x0d, "$"
BIOS_MSG:
        db 0x0a, 0x0d, "BIOS test-function", 0x0a, 0x0d
        db 0x0a, 0x0d, " 1 Clear the screen"
        db 0x0a, 0x0d, " 2 Write a character"
        db 0x0a, 0x0d, " 3 Input test"
        db 0x0a, 0x0d, " 4 Delay test"
        db 0x0a, 0x0d, " 5 Input character display"
        db 0x0a, 0x0d, " 6 Wrapped text output test"
        db 0x0a, 0x0d, " 7 Dump game sizes"
        db 0x0a, 0x0d, " 8 Return to the game"
        db 0x0a, 0x0d
        db "$"
bios_size_dump_code:
        db 0x0a, 0x0d, "Code: $"
bios_size_dump_text:
        db 0x0a, 0x0d, "Text: $"
bios_size_dump_total:
        db 0x0a, 0x0d, "Total: $"
bios_wrap_test_message:
        db "This is a long message which is entered as a string of text, it is expected that this will need to be wrapped a bunch of times since we've configured the width of the display to be ten characters.$"
input_test_message:
        db "Please enter a string:$"
delay_test_message:
        db "Test our delay function:", 0x0a, 0x0d,0x0a, 0x0d,"$"
you_entered_message:
        db 0x0a, 0x0d, "You entered: $"
no_input:
        db "You didn't enter anything.$"
you_pressed:
        db 0x0a,0x0d,0x0a,0x0d, "You pressed:$"
press_key_continue:
        db 0x0a, 0x0d, 0x0a, 0x0d, "Press a key to continue $"
HELP_MSG:
        db 0x0a, 0x0d, "The following commands are available:", 0x0a, 0x0d, "$"
EXAMINE_WHAT_MSG:
        db 0x0a, 0x0d, "Examine what? Please try again.", 0x0a, 0x0d, "$"
GO_WHERE_MSG:
        db 0x0a, 0x0d, "Go where?  Please try again.", 0x0a, 0x0d, "$"
GET_WHAT_MSG:
        db 0x0a, 0x0d, "Take what? Please try again.", 0x0a, 0x0d, "$"
DROP_WHAT_MSG:
        db 0x0a, 0x0d, "Drop what? Please try again.", 0x0a, 0x0d, "$"
WRAP_IS_MSG:
        db 0x0a, 0x0d, "Wrapping is set to $"
USE_WHAT_MSG:
        db 0x0a, 0x0d, "Use what? Please try again.", 0x0a, 0x0d, "$"
cant_take_that_msg:
        db 0x0a, 0x0d, "You can't take that.", 0x0a, 0x0d, "$"
you_drop_it:
        db 0x0a, 0x0d, "You drop it.", 0x0a, 0x0d, "$"
inventory_empty_message:
        db 0x0a, 0x0d, "You are not carrying anything", 0x0a, 0x0d, "$"
you_carrying_message:
        db 0x0a, 0x0d, "You are carrying:", 0x0a, 0x0d, "$"
you_see_message:
        db 0x0a, 0x0d, "You see:", 0x0a, 0x0d, "$"
use_generic:
        db 0x0a, 0x0d, "Nothing seems to happen.", 0x0a, 0x0d, "$"
item_not_present_msg:
        db  0x0a, 0x0d, "I can't see that here!", 0x0a, 0x0d, "$"
not_carrying_item_msg:
        db 0x0a, 0x0d, "You're not carrying that!", 0x0a, 0x0d, "$"
MIRROR_DROP_FUN:
        db 0x0a, 0x0d, "You drop the mirror, which cracks and breaks.", 0x0a, 0x0d, "$"
SLEEP_START_MSG:
        db 0x0a, 0x0d, "You lay down and take a small nap.", 0x0a, 0x0d
        db "$"
SLEEP_END_MSG:
        db 0x0a, 0x0d, "You jerk awake, unsure of how much time has passed or how much closer the boat, "
        db "and yourself, are to certain doom.", 0x0a, 0x0d
        db "$"
WAIT_CMD_MSG:
        db 0x0a, 0x0d, "You wait for a moment, lost in thought.", 0x0a, 0x0d, "$"
TORCH_ON_MSG:
        db 0x0a, 0x0d, "You turn on the torch.", 0x0a, 0x0d, "$"
TORCH_OFF_MSG:
        db 0x0a, 0x0d, "You turn the torch off.", 0x0a, 0x0d, "$"
you_were_eaten:
        db 0x0a, 0x0d, "You were eaten by a grue.", 0x0a, 0x0d,0x0a, 0x0d
        db "At least you were spared the sight of the ship crashing into the rocks, and no "
        db "doubt causing the lighthouse itself to collapse, dooming you all.", 0x0a, 0x0d
        db "$"
grue_message:
        db 0x0a, 0x0d, "You hear the scrabble of claws getting closer, is the grue about to attack?", 0x0a, 0x0d, "$"
ship_closer_msg:
        db 0x0a, 0x0d, "The ship is getting closer!", 0x0a, 0x0d, 0x0a, 0x0d
        db "Hurry up, or you'll all be dead!", 0x0a, 0x0d, "$"
NOW_YOU_SEE:
        db "Now you can see where you are:", 0x0a, 0x0d, "$"
THE:
        db " THE "
ON:
        db " ON "
usage_message:
        db 0x0a, 0x0d
        db "        .n.         "
IF SPECTRUM
ELSE
        db 27, "[1;4m"
ENDIF
        db "The lighthouse of doom"
IF SPECTRUM
ELSE
        db 27, "[1;0m"
ENDIF
        db 0x0a, 0x0d
        db "       /___\\ ", 0x0a, 0x0d
        db "       [|||]        ", 0x0a, 0x0d
        db "       [___]        ", 0x0a, 0x0d
        db "       }-=-{        ", 0x0a, 0x0d
        db "       |-\" |        ", 0x0a, 0x0d
        db "       |.-\"|                p", 0x0a, 0x0d
        db "~^=~^~-|_.-|~^-~^~ ~^~ -^~^~|\\ ~^-~^~-", 0x0a, 0x0d
        db "^   .=.| _.|__  ^       ~  /| \\", 0x0a, 0x0d
        db " ~ /:. \\\" _|_/\    ~       /_|__\\  ^", 0x0a, 0x0d
        db ".-/::.  |   |\"\"|-._    ^   ~~~~", 0x0a, 0x0d
        db "  `===-'-----'\"\"`  '-.              ~", 0x0a, 0x0d
        db "                 __.-'      ^", 0x0a, 0x0d
        db "", 0x0a, 0x0d
        db "Written by Steve Kemp in 2021, version "

;
; This file is updated with the current git-tag by `make release`.
;
; The github action/pipeline will do that when a new release is issued.
;
include "version.z80"

        db ".", 0x0a, 0x0d
        db 0x0a, 0x0d
        db "  https://github.com/skx/lighthouse-of-doom"
        db 0x0a, 0x0d
        db 0x0a, 0x0d
        db "Any references to the Paw Patrol are entirely deliberate."
        db 0x0a, 0x0d, 0x0a, 0x0d
        db "Press any key to start.$"


play_again_msg:
        db 0x0a, 0x0d, "Play again? (y/n)$"
play_again_no_msg:
        db 0x0a, 0x0d, "Resetting", 0x0a, 0x0d, "$"
PLAYER_DEAD_MESSAGE:
        db 0x0a, 0x0d, "Unfortunately you took too long to fix the broken light."
        db 0x0a, 0x0d, "The ship ploughs into the base of your lighthouse, causing it to collapse around"
        db 0x0a, 0x0d, "you."
        db 0x0a, 0x0d, "You're buried and helpless, and as the darkness consumes you the sounds of the"
        db 0x0a, 0x0d, "sailors thrashing in the water reach you, from a distance."
        db 0x0a, 0x0d, "Let us hope some of them can swim to shore.."

        db "Game over - you're dead."
        db 0x0a, 0x0d,"$"
PLAYER_WON_MESSAGE:
        db 0x0a, 0x0d
        db "You won!"
        db 0x0a, 0x0d,"$"
PLAYER_TURN_COUNT:
        db "You've played $"
PLAYER_TURN_COUNT_END:
        db " turns."
        db 0x0a, 0x0d,"$"
LOOK_FUNCTION_PREFIX:
        db 0x0a, 0x0d, "You are in $"
LOOK_AT:
        db "LOOK AT "

;
; Location text
;
location_0_short:
        db "the top floor of the lighthouse.", 0x0a, 0x0d, 0x0a, 0x0d, "$"
location_0_long:
IF SPECTRUM
ELSE
        db "The lighthouse has a spiral staircase which runs from top to bottom.", 0x0a, 0x0d, 0x0a, 0x0d
ENDIF
        db "Through the window you can see the lights of an approaching ship, and you know "
        db "that without the lighthouse's beacon it will surely crash upon the rocks your "
        db "lighthouse is built upon. "

IF SPECTRUM
        db 0x0a, 0x0d
ELSE
        db "If the ship crashes not only will the sailors drown, "
ENDIF
        db "the lighthouse itself is liable to be seriously damaged.", 0x0a, 0x0d, 0x0a, 0x0d
        db "Too bad the lighthouse light doesn't seem to be working..", 0x0a, 0x0d
        db "$"

location_1_short:
        db "the middle floor of the lighthouse.", 0x0a, 0x0d, 0x0a, 0x0d, "$"
location_1_long:
        db "This seems to be a relaxation-room, you see some comfy chairs, a work-desk, as well as various odds and ends. "
        db "An impressive painting hangs over the desk, and a dog sleeps in a basket "
        db "to the side of it.", 0x0a, 0x0d
        db "$"

location_2_short:
        db "the ground floor of the lighthouse.", 0x0a, 0x0d, 0x0a, 0x0d, "$"
location_2_long:
        db "The ground floor seems very crowded, with most of the room "
        db "taken up by a coat-rack, boots, and similar things.", 0x0a, 0x0d
        db "$"

location_3_short:
        db "the lighthouse basement.", 0x0a, 0x0d, 0x0a, 0x0d, "$"
location_3_long:
        db "This seems to be a graveyard for discarded machinery, and", 0x0a, 0x0d
        db "other random junk.", 0x0a, 0x0d
        db "$"

location_4_short:
        db "a dark place.", 0x0a, 0x0d, 0x0a, 0x0d, "$"
location_4_long:
        db "You cannot see anything, but you can certainly smell something animal-like.", 0x0a, 0x0d, 0x0a, 0x0d
        db "In the distance you hear the scrabble of claws on concrete.", 0x0a, 0x0d, 0x0a, 0x0d
        db "Could you have discovered the haunt of the mythical grue?", 0x0a, 0x0d
        db "$"


;
; Item text
;
item_0_name: db "GENERATOR"
item_0_desc: db "A small, portable, generator.$"
item_0_long: db "This is a small and easily carried diesel-power generator.", 0x0a, 0x0d
             db "The generator seems to be full of fuel, and ready to go.", 0x0a, 0x0d
             db "The important thing is probably working out where to use it.", 0x0a, 0x0d
             db "$"

item_1_name:  db "MIRROR"
item_1_desc:  db "A small mirror.$"
item_1_long:  db "The mirror doesn't seem to be anything special.", 0x0a, 0x0d
              db "But your reflection?  It looks fabulous.", 0x0a, 0x0d
              db "$"

item_1_desc_broken:  db "A small broken mirror.$"
item_1_long_broken:  db "The mirror was once small and delicate.", 0x0a, 0x0d
              db "But now it shows a warped reflection of yourself,", 0x0a, 0x0d
              db "which is oddly unsettling.", 0x0a, 0x0d
              db "$"

item_3_name:  db "TORCH"
item_3_desc_off:  db "A small torch.$"
item_3_desc_on:   db "A small torch, which is turned on.$"
item_3_long_off:  db "The torch doesn't seem to be anything special,"
                  db 0x0a, 0x0d
                  db "but you do notice that it contains batteries and can be turned on easily.", 0x0a, 0x0d
                  db "$"
item_3_long_on:  db "The torch doesn't seem to be anything special."
                 db 0x0a, 0x0d, "$"

item_5_name:  db "DOG"
item_5_long:  db "The dog seems to be sleeping quite deeply.  As you examine him ", 0x0a, 0x0d
              db "he mutters something about 'Apollo the Super-Pup' in his sleep,", 0x0a, 0x0d
              db "before settling back into silence.", 0x0a, 0x0d
              db "$"

item_6_name:  db "PAINTING"
item_6_long:  db "The painting shows a teenager with spiky hair, surrounded by a group of dogs.$"

item_7_name: db "RUG"
item_7_desc: db "A small rug.$"
item_7_long: db "The rug is made of coarse wool, roughly woven, but there's nothing remarkable "
             db "about it.", 0x0a, 0x0d, "$"

item_8_name: db "BOOK"
item_8_desc: db "A small black book.$"
item_8_long: db "The little black book seems to contain names and phone numbers:", 0x0a, 0x0d, 0x0a, 0x0d
             db "    Police    - 999", 0x0a, 0x0d
             db " Ambulance    - 999", 0x0a, 0x0d
             db " Fire Service - 999", 0x0a, 0x0d
             db " Paw Patrol   - 999", 0x0a, 0x0d
             db 0x0a, 0x0d
             db "Too bad there are no instructions on powering the main light, although there is "
             db "an advert for a portable diesel generator being used as a bookmark.$"

item_9_name: db "DESK"
item_9_long: db "The desk is made of solid wood, unlike everything else in the room.", 0x0a, 0x0d, "$"
desk_has_meteor:
        db 0x0a, 0x0d
        db "Towards the back of the desk you notice a small glowing rock, possibly a meteor?", 0x0a, 0x0d, "$"


item_10_name: db "TELEPHONE"
item_10_desc: db "A telephone, wired to the wall.$"
item_10_long: db "The telephone is an average telephone, which looks like it was made in the 80s.  Perhaps you should try to CALL somebody?", 0x0a, 0x0d, "$"

item_11_name: db "TRAPDOOR"
item_11_closed: db "A trapdoor.$"
item_11_open: db "An open trapdoor.$"
item_11_desc_closed: db "You cannot see anything special about the trapdoor.", 0x0a, 0x0d
              db "Perhaps you should open it to explore further?", 0x0a, 0x0d, "$"
item_11_desc_open: db "An average looking trapdoor.", 0x0a, 0x0d, "$"


item_13_name: db "METEOR"
item_13_desc: db "A meteor fragment$"
item_13_long: db "This piece of rock looks like it came from a larger meteor, it is glowing with an eerie light.$"

; For "EXAMINE ROOM"
item_14_name: db "ROOM"

item_15_name: db "GRUE"

item_16_name: db "BASKET"
item_16_long: db "The dog-basket is a faded red colour, and covered with dog-hairs.", 0x0a, 0x0d, "$"

item_17_name: db "COAT-RACK"
item_17_long: db "The coat-rack looks normal.", 0x0a, 0x0d, "$"

item_18_name: db "CHAIR"
item_18_long: db "The chair is just a chair", 0x0a, 0x0d, "$"

item_19_name: db "CHAIRS"
item_19_long: db "The chairs look very comfortable, but also covered in slightly too much dog-hair.", 0x0a, 0x0d, "$"

item_20_name: db "BOOTS"
item_20_long: db "The boots are black, and shiny.", 0x0a, 0x0d, 0x0a, 0x0d
              db "They're probably made for walking?", 0x0a, 0x0d, "$"

item_21_name: db "JUNK"
item_21_long: db "The junk seems too fragile to move around and examine.", 0x0a, 0x0d, "$"

item_22_name: db "MACHINERY"
item_22_long: db "The machinery doesn't seem very special.", 0x0a, 0x0d, "$"

; }}



;********************************************************************
; Table Area
;********************************************************************
; {{

;
; Our command-table contains the commands we accept, a pointer to their
; handlers, and a "hidden" flag.
;
; The HELP command will show all non-hidden commands.
;
; NOTE: There is no help-text for the commands
;
command_table:
        DEFB 3, 'CLS', 1
          DEFW bios_clear_screen
        DEFB 4, 'DOWN', 0
          DEFW down_function
        DEFB 4, 'DROP', 0
          DEFW drop_function
        DEFB 7, 'EXAMINE', 0
          DEFW examine_function
        DEFB 3, 'GET', 0
          DEFW get_function
        DEFB 4, 'HELP', 0
          DEFW help_function
        DEFB 9, 'INVENTORY', 0
          DEFW inventory_function
        DEFB 4, 'LOOK', 0
          DEFW look_function
        DEFB 4, 'QUIT', 0
          DEFW quit_function
        DEFB 4, 'WRAP', 0
          DEFW wrap_function
        DEFB 4, 'BIOS', 1
          DEFW bios_function
        DEFB 5, 'TURNS', 0
          DEFW turns_function
        DEFB 2, 'UP', 0
          DEFW up_function
        DEFB 3, 'USE', 0
          DEFW use_function
        ;; synonyms
        DEFB 5, 'CLEAR', 0
          DEFW bios_clear_screen
        DEFB 2, 'GO', 1
          DEFW go_function
        DEFB 4, 'TAKE', 1
          DEFW get_function
        DEFB 6, 'PICKUP', 1
          DEFW get_function
        DEFB 4, 'OPEN', 1     ; open trapdoor
          DEFW use_function
        DEFB 5, 'CLOSE', 1    ; close trapdoor
          DEFW use_function
        DEFB 4, 'READ', 1     ; read book
          DEFW use_function
        DEFB 5, 'LIGHT', 1
          DEFW use_function
        DEFB 6, 'SWITCH', 1   ; switch on generator, etc
          DEFW use_function
        DEFB 4, 'TURN', 1     ; turn on torch, etc.
          DEFW use_function
        ;; easter-eges
        DEFB 4, 'CALL', 1
          DEFW call_function
        DEFB 4, 'DIAL', 1
          DEFW call_function
        DEFB 4, 'FUCK', 1
          DEFW bad_language_function
        DEFB 5, 'PHONE', 1
          DEFW call_function
        DEFB 4, 'SHIT', 1
          DEFW bad_language_function
        DEFB 5, 'XYZZY', 1
          DEFW magic_function
        DEFB 5, 'SLEEP', 1
          DEFW sleep_function
        DEFB 4, 'WAIT', 1
          DEFW wait_function
        ;; abbreviations
        DEFB 1, 'L', 1
          DEFW look_function
        DEFB 3, 'INV', 1
          DEFW inventory_function
        ;; end of table
        DEFB 0


;
; People table
;
; Similar to the command-table, each entry is:
;
;  LENGTH "NAME HERE" Ptr-To-Response
;
people_table:
        DEFB 3, '112'
             DEFW call_911_msg
        DEFB 3, '911'
             DEFW call_911_msg
        DEFB 3, '999'
             DEFW call_999_msg
        DEFB 6, 'POLICE'
             DEFW call_police_msg
        DEFB 5, 'RYDER'
             DEFW call_ryder_msg
        DEFB 5, 'RIDER'
             DEFW call_ryder_msg
        DEFB 10, 'PAW PATROL'
             DEFW call_ryder_msg
        DEFB 4, 'SKYE'
             DEFW call_skye_msg
        DEFB 5, 'STEVE'
             DEFW call_steve_msg
        DEFB 6, 'RUBBLE'
             DEFW call_rubble_msg
        DEFB 2, 'ME'
             DEFW call_me_msg
        DEFB 12, 'GHOSTBUSTERS'
             DEFW call_ghostbusters_msg
        DEFB 0


;
; Location table
;
; Each location contains a pointer to a short-description, a pointer to
; a long description, and a seen-flag.
;
location_table:
        DEFW location_0_short   ; top-floor
        DEFW location_0_long
        DB 0 ; seen-flag
location_first:
        DEFW location_1_short   ; middle-floor
        DEFW location_1_long
        DB 0 ; seen-flag

        DEFW location_2_short   ; ground-floor
        DEFW location_2_long
        DB 0 ; seen-flag

        DEFW location_3_short   ; basement
        DEFW location_3_long
        DB 0 ; seen-flag

        DEFW location_4_short   ; dark-place
        DEFW location_4_long
        DB 0 ; seen-flag

LOCATION_ENTRY_LENGTH: EQU location_first - location_table


;
; Item table - Each item contains:
;
;   1. A pointer to the (internal) name.
;   2. A pointer to a short description - empty for "hidden" items
;   3. A pointer to a long description - shown by "EXAMINE $object"
;   4. A pointer to a take-function.
;   5. A pointer to a drop-function.
;   6. A pointer to an examine-function.
;        If this is null then the extended description will be shown.
;   7. A pointer to a use-function.
;   8. A byte used for item-state.
;   9. A byte to specify whether this can be taken.
;  10. A byte to contain the location of the object.
;       0xff == the player is carrying it.
;       0xfe == can be found but won't be displayed when a location is entered.
;
; We might add further pointers in the future, to allow custom behaviour
; on a per-object basis.  Hopefully the use of calculated offsets relating
; to the item-structure will make that a painless process.
;
items:
item_name:
        DEFW item_0_name  ; generator
item_description_ptr:
        DEFW item_0_desc
item_ext_description_ptr:
        DEFW item_0_long
item_take_ptr:
        DEFB 0,0          ; No take function
item_drop_ptr:
        DEFB 0,0          ; No drop function
item_examine_ptr:
        DEFB 0,0          ; No examine function
item_use_ptr:
        DEFW use_generator_fn ; handler
item_state:
        DEFB 0            ; Item state
item_collectable:
        DEFB 1            ; this item can be picked up
item_location:
        DEFB 0x03         ; basement


;
; We have a function called "get_item_by_name" which returns a pointer
; to the start of the item's table-entry.
;
; Rather than manually counting bytes to get access to the fields we
; use some constants to access them - these constants are calculated here.
;
; e.g. Find a torch and get the location:
;
;         find the item, so the base is in IX
;
;         ld a, (IX+ ITEM_TABLE_LOCATION_OFFSET)
;
ITEM_TABLE_NAME_OFFSET:            EQU item_name - items
ITEM_TABLE_DESCRIPTION_OFFSET:     EQU item_description_ptr - items
ITEM_TABLE_EXT_DESCRIPTION_OFFSET: EQU item_ext_description_ptr - items
ITEM_TABLE_TAKE_OFFSET:            EQU item_take_ptr - items
ITEM_TABLE_DROP_OFFSET:            EQU item_drop_ptr - items
ITEM_TABLE_EXAMINE_OFFSET:         EQU item_examine_ptr - items
ITEM_TABLE_USE_OFFSET:             EQU item_use_ptr - items
ITEM_TABLE_COLLECTABLE_OFFSET:     EQU item_collectable - items
ITEM_TABLE_STATE_OFFSET:           EQU item_state - items
ITEM_TABLE_LOCATION_OFFSET:        EQU item_location - items

        ; description of the mirror changes when it is dropped
        ; so we have labels here to update the strings that
        ; are pointed to.
item_first:
        DEFW item_1_name  ; mirror
item_first_desc:
        DEFW item_1_desc
item_first_edesc:
        DEFW item_1_long
        DEFB 0,0            ; No take function
        DEFW drop_mirror_fn ; custom drop function
        DEFB 0,0            ; no custom examine function
        DEFB 0,0            ; No use function
        DEFB MIRROR_OK      ; item state
        DEFB 1              ; this item can be picked up
        DEFB 0x01           ; middle-floor


        ; description of the torch changes when it is lit/unlit
        ; so we have labels here to update the strings that
        ; are pointed to.
        DEFW item_3_name  ; torch
torch_item_desc:
        DEFW item_3_desc_off
torch_item_long:
        DEFW item_3_long_off
        DEFB 0,0                ; No take function
        DEFB 0,0                ; No drop function
        DEFB 0,0                ; No examine function
        DEFW use_torch_fn       ; USE TORCH
        DEFB TORCH_STATE_UNLIT  ; item state
        DEFB 1                  ; this item can be picked up
        DEFB 0x00               ; top-floor

        DEFW item_5_name  ; dog
        DEFB 0,0          ; NO DESCRIPTION - hidden item
        DEFW item_5_long
        DEFB 0,0          ; No take function
        DEFB 0,0          ; No drop function
        DEFB 0,0          ; No examine function
        DEFB 0,0          ; No use function
        DEFB 0            ; item state
        DEFB 0            ; this item cannot be picked up
        DEFB 0x01         ; middle-floor

        DEFW item_6_name  ; painting
        DEFB 0,0          ; NO DESCRIPTION - hidden item
        DEFW item_6_long
        DEFB 0,0          ; No take function
        DEFB 0,0          ; No drop function
        DEFB 0,0          ; No examine function
        DEFB 0,0          ; No use function
        DEFB 0            ; item state
        DEFB 0            ; this item cannot be picked up
        DEFB 0x01         ; middle-floor

        DEFW item_7_name  ; rug
        DEFW item_7_desc
        DEFW item_7_long
        DEFW take_rug_fn     ; Custom take-function
        DEFB 0,0             ; No drop function
        DEFW examine_rug_fn  ; No examine function
        DEFB 0,0             ; No use function
        DEFB 0               ; item state
        DEFB 1               ; this item can be picked up
        DEFB 0x02            ; ground-floor

        DEFW item_8_name  ; book
        DEFW item_8_desc
        DEFW item_8_long
        DEFB 0,0          ; No take function
        DEFB 0,0          ; No drop function
        DEFB 0,0          ; No examine function
        DEFW use_book_fn  ; Custom use function
        DEFB 0            ; item state
        DEFB 1            ; this item can be picked up
        DEFB 0x01         ; middle-floor

        DEFW item_9_name      ; desk
        DEFB 0,0              ; NO DESCRIPTION - hidden item
        DEFW item_9_long
        DEFB 0,0              ; No take function
        DEFB 0,0              ; No drop function
        DEFW examine_desk_fn  ; custom examine function
        DEFB 0,0              ; No use function
        DEFB 0                ; item state
        DEFB 0                ; this item cannot be picked up
        DEFB 0x01             ; middle-floor

        DEFW item_10_name ; telephone
        DEFB 0,0          ; NO DESCRIPTION - hidden item
        DEFW item_10_long
        DEFB 0,0          ; No take function
        DEFB 0,0          ; No drop function
        DEFB 0,0          ; no custom examine function
        DEFB 0,0          ; No use function
        DEFB 0            ; item state
        DEFB 0            ; this item cannot be picked up
        DEFB 0x01         ; middle-floor

        ; description of the trapdoor changes when it is opened/
        ; closed.  So we have labels here to update the strings
        ; that are pointed to.
        DEFW item_11_name ; trapdoor
trapdoor_desc:
        DEFW item_11_closed
trapdoor_edesc:
        DEFW item_11_desc_closed
        DEFB 0,0                      ; No take function
        DEFB 0,0                      ; No drop function
        DEFB 0,0                      ; no custom examine function
        DEFW use_trapdoor_fn          ; open function
        DEFB TRAPDOOR_STATE_INVISIBLE ; item state
        DEFB 0                        ; this item cannot be picked up
        DEFB ITEM_INVISIBLE           ; hidden until the rug is moved

        DEFW item_13_name ; meteor
        DEFW item_13_desc
        DEFW item_13_long
        DEFW take_meteor_fn ; Custom take function
        DEFB 0,0            ; No drop function
        DEFB 0,0            ; no custom examine function
        DEFB 0,0            ; No use function
        DEFB 0              ; item state
        DEFB 0              ; this item cannot be picked up
        DEFB ITEM_INVISIBLE ; hidden until the desk is examined

        DEFW item_14_name    ; room
        DEFB 0,0             ; NO DESCRIPTION - hidden item
        DEFB 0,0             ; No extended description
        DEFB 0,0             ; Custom take function
        DEFB 0,0             ; No drop function
        DEFW examine_room_fn ; EXAMINE ROOM -> custom function
        DEFB 0,0             ; No use function
        DEFB 0               ; item state
        DEFB 0               ; this item cannot be picked up
        DEFB ITEM_INVISIBLE  ; hidden.

        DEFW item_15_name    ; grue
        DEFB 0,0             ; NO DESCRIPTION - hidden item
        DEFB 0,0             ; No extended description
        DEFB 0,0             ; Custom take function
        DEFB 0,0             ; No drop function
        DEFB 0,0             ; No custom examine function
        DEFB 0,0             ; No use function
        DEFB 0               ; item state
        DEFB 0               ; this item cannot be picked up
        DEFB ITEM_INVISIBLE  ; hidden.

        DEFW item_16_name     ; dog-basket
        DEFB 0,0              ; NO DESCRIPTION - hidden item
        DEFW item_16_long
        DEFB 0,0              ; No take function
        DEFB 0,0              ; No drop function
        DEFB 0,0              ; No custom examine function.
        DEFB 0,0              ; No use function
        DEFB 0                ; item state
        DEFB 0                ; this item cannot be picked up
        DEFB 0x01             ; middle-floor

        DEFW item_17_name     ; coat-rack
        DEFB 0,0              ; NO DESCRIPTION - hidden item
        DEFW item_17_long
        DEFB 0,0              ; No take function
        DEFB 0,0              ; No drop function
        DEFB 0,0              ; No custom examine function.
        DEFB 0,0              ; No use function
        DEFB 0                ; item state
        DEFB 0                ; this item cannot be picked up
        DEFB 0x02             ; ground-floor

        DEFW item_18_name     ; chair
        DEFB 0,0              ; NO DESCRIPTION - hidden item
        DEFW item_18_long
        DEFB 0,0              ; No take function
        DEFB 0,0              ; No drop function
        DEFB 0,0              ; No custom examine function.
        DEFB 0,0              ; No use function
        DEFB 0                ; item state
        DEFB 0                ; this item cannot be picked up
        DEFB 0x01             ; middle-floor

        DEFW item_19_name     ; chairs
        DEFB 0,0              ; NO DESCRIPTION - hidden item
        DEFW item_19_long
        DEFB 0,0              ; No take function
        DEFB 0,0              ; No drop function
        DEFB 0,0              ; No custom examine function.
        DEFB 0,0              ; No use function
        DEFB 0                ; item state
        DEFB 0                ; this item cannot be picked up
        DEFB 0x01             ; middle-floor

        DEFW item_20_name     ; boots
        DEFB 0,0              ; NO DESCRIPTION - hidden item
        DEFW item_20_long
        DEFB 0,0              ; No take function
        DEFB 0,0              ; No drop function
        DEFB 0,0              ; No custom examine function.
        DEFB 0,0              ; No use function
        DEFB 0                ; item state
        DEFB 0                ; this item cannot be picked up
        DEFB 0x02             ; ground-floor

        DEFW item_21_name     ; junk
        DEFB 0,0              ; NO DESCRIPTION - hidden item
        DEFW item_21_long
        DEFB 0,0              ; No take function
        DEFB 0,0              ; No drop function
        DEFB 0,0              ; No custom examine function.
        DEFB 0,0              ; No use function
        DEFB 0                ; item state
        DEFB 0                ; this item cannot be picked up
        DEFB 0x03             ; basement

        DEFW item_22_name     ; machinery
        DEFB 0,0              ; NO DESCRIPTION - hidden item
        DEFW item_22_long
        DEFB 0,0              ; No take function
        DEFB 0,0              ; No drop function
        DEFB 0,0              ; No custom examine function.
        DEFB 0,0              ; No use function
        DEFB 0                ; item state
        DEFB 0                ; this item cannot be picked up
        DEFB 0x03             ; basement

item_last:

; length of an entry in the item table.
ITEM_ENTRY_LENGTH: EQU item_first - items
ITEM_COUNT: EQU ( item_last - items ) / ITEM_ENTRY_LENGTH
; }}




;********************************************************************
; Buffer Area
;********************************************************************
; {{

;
; This is the buffer which is used for reading a line of text from the
; CP/M BIOS.
;
; The way this works is you pass the address of a region of memory, the
; first byte is the length of the buffer.
;
; On return the second byte of the buffer will be populated by the
; amount of text which was read, then the input itself:
;
;    http://www.gaby.de/cpm/manuals/archive/cpm22htm/ch5.htm#Function_10
;
INPUT_BUFFER:
        db MAX_INPUT_LENGTH  ; size of our input-buffer
        db 0x00              ; Count of characters returned.



;
; A temporary buffer, available to all handlers.
;
; This is placed after the input-buffer above, and is defined as being 50
; bytes long.  It is used for finding the argument to a handler.
;
; For example:
;
;   CALL RYDER
;
; The CALL handler will be invoked, and the object of the call, "RYDER" will
; be copied into this buffer for table-lookup.
;
TMP_BUFFER: EQU INPUT_BUFFER + 255
TMP_BUFFER_LEN: EQU 50

; }}

;
; Our source code ends here.
;
; We use this label to calculate how many bytes to decrypt when we
; launch - if that support is enabled.
;
end_of_source:

END ENTRYPOINT
