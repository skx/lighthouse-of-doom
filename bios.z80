; bios.z80
;
; This file contains the common primitives we use for interfacing
; with CP/M or the ZX Spectrum (48k).
;
; We don't use many primitives, but we do need some facilities from
; the operating system, or the Spectrum ROM:
;
;  1.  Pause for a keypress.
;
;  2.  Clear the screen.
;
;  3.  Output a string.
;
;  4.  Allow the user to enter input
;
; The routines here will work for both systems, and contain the only
; platform-specific code we need.
;


; Last keyboard input as set by the Spectrum ROM
LASTK: EQU 0x5C08


;
; Initialization routine for the BIOS, if needed
;
bios_init:

IF SPECTRUM
   ld a,2
   call 5633    ; CHAN_OPEN

   ld hl, 23692
   ld (hl),255
   ret

ELSE
   ret
ENDIF


;
; Clear the screen.
;
bios_clear_screen:

IF SPECTRUM
        PUSH_ALL
        ld a,2
        call 0x1601  ; ROM_OPEN_CHANNEL
        call 0x0DAF  ; ROM_CLS
        POP_ALL
        ret

ELSE
        ld de, cpm_clear_screen_msg
        call bios_output_string
        ret

cpm_clear_screen_msg:
        db 27, "[2J"            ; "clear"
        db 27, "[H"             ; "home"
        db "$"
ENDIF


;
; Await a keypress, which is returned in the A-register
;
bios_await_keypress:

IF SPECTRUM
       push hl
       LD   HL,LASTK
       LD   A,255
       LD (HL),A
wkey:  CP   (HL)
       JR   Z,wkey

       ; get the key, and return it.
       ld a,(HL)
       pop hl
       ret

ELSE
       ld c,  0x01
       call 0x0005
       ret
ENDIF



;
; Output a single character, stored in the E register
;
bios_output_character:

IF SPECTRUM
        PUSH_ALL
        ld a,e
        RST 0x10
        POP_ALL
        ret
ELSE
        ld c, 0x02
        call 0x005
        ret
ENDIF


;
; Output a string, terminated by "$".
;
; The address of the string is stored in DE
;
; NOTE: / TODO: The Spectrum will process the string character by
;               character to skip the CR/NL things it can't show.
;
bios_output_string:

IF SPECTRUM
        PUSH_ALL
        push DE
        pop HL      ; HL contains the string
bios_output_repeat:
        ld a,(hl)   ; Get the character
        cp 0x0d     ; Ignore the newline & cr.
        jr z, skip
        cp 0x0a
        jr z, skip
        cp '$'      ; end of string?
        jr z, bios_output_done
        ld e,a      ; output the single character
        call bios_output_character
skip:
        inc hl
        jr bios_output_repeat
bios_output_done:
        POP_ALL
        ret

ELSE
        ld c, 0x09
        call 0x005
        ret
ENDIF


;
; Prompt the user for a line of input.
;
; The way this works is you pass the address of a region of memory,
; in the DE register.  The first byte is the length of the buffer.
;
; On return the second byte of the buffer will be populated by the
; amount of text which was read, then the input itself:
;
; DE points to the memory buffer;
;
;  0x00 - buffer size
;  0x01 - read-length
;  0x02 ... char..
bios_read_input:
IF SPECTRUM
        PUSH_ALL

        ; Move the cursor to the bottom of the screen, and
        ; display a prompt
        PUSH_ALL
        ld a,22          ; AT code.
        rst 16
        ld a,21          ; vertical coord.
        rst 16           ; set the vertical coord
        ld a,0           ; horizontal position.
        rst 16           ; set the horizontal coord.

        ld e, ">"
        call bios_output_character
        POP_ALL

        push de
        pop  hl   ; buffer -> hl

        inc hl    ; skip to the returned size
        inc de

        xor a
        ld (hl),a  ; size is now zero
        inc hl ; point to the character

read_input_again:
        ; read a char
        call bios_await_keypress

        cp 13
        jr z, read_input_over

        ; display it
        push de
        ld e,a
        call bios_output_character
        pop de

        ; add the character to the buffer
        ld (hl),a
        inc hl

        ; increase the input count
        ld a,(de)
        inc a
        ld (de),a

        ; repeat
        jr read_input_again

read_input_over:
        ; move the cursor to the top of the screen, and
        ; prepare for output again.
        call bios_clear_screen

        POP_ALL
        ret
ELSE
        ; 3. show the prompt
        ld de, prompt_message
        call bios_output_string

        ld c, 0x0A
        call 0x005
        ret
prompt_message:
        db 0x0a, 0x0d,">$"
ENDIF
